{block #title}Algorithms{/block}
{block #chapter}B.{/block}
{block #content}

<h3>List of all algorithms in JCOP</h3>

<p>
  In <a href="#table-1">table 1</a> is a list of all algorithms bundled with JCOP, along with brief description, type of
  search and required problem interfaces. Note that both graph search algorithms listed here extends
  {javadoc "algorithm.graphsearch.GraphSearch"} which reduces work required to create own graph search algorithm to
  almost no more than creating a queue for it. 
</p>

<table class="full" id="table-1">
  <tr>
    <th>Name</th>
    <th>Description</th>
    <th>Search type</th>
    <th>Required interfaces</th>
  </tr>
  <tr>
    <td><a href="#breadth-first-search">BreadthFirstSearch</a></td>
    <td>Graph search algorithm where newly expanded elements are placed to the end of queue. Slow but finds optimal
    solution.</td>
    <td>Graph search</td>
    <td>{javadoc "problem.StartingConfigurationProblem"}</td>
  </tr>
  <tr>
    <td><a href="#depth-first-search">DepthFirstSearch</a></td>
    <td>Graph search algorithm where newly expanded elements are placed to the beginning of queue. Requires less memory
     than BreadthFirstSearch, but doest not guarantee shortest path to solution.</td>
    <td>Graph search</td>
    <td>{javadoc "problem.StartingConfigurationProblem"}</td>
  </tr>
  <tr>
    <td><a href="#genetic-algorithm">GeneticAlgorithm</a></td>
    <td>Creates population of solutions from previous population by reproduction of two configurations.</td>
    <td>Global search</td>
    <td>{javadoc "problem.RandomConfigurationProblem"}<br />
    {javadoc "problem.GlobalSearchProblem"}
    </td>
  </tr>
  <tr>
    <td><a href="#graph-search-algorithm">GraphSearch</a></td>
    <td>Abstract base for all graph search algorithms, requires queue to be implemented at least.</td>
    <td>Graph search</td>
    <td>{javadoc "problem.StartingConfigurationProblem"}</td>
  </tr>
  <tr>
    <td><a href="#simulated-annealing">SimulatedAnnealing</a></td>
    <td>Accept changes into worse configuration with lower probability with increasing time, in the end accepts almost
    only better configurations.</td>
    <td>Local search</td>
    <td>{javadoc "problem.RandomConfigurationProblem"}<br />
    or {javadoc "problem.StartingConfigurationProblem"}
    </td>
  </tr>
</table>

<h3 id="breadth-first-search">BreadthFirstSearch</h3>

<p>
  {javadoc "algorithm.graphsearch.bfs.BreadthFirstSearch"} traverses over all possible configurations. First expanded
  configurations are processed first. Is very slow (since it traverses all configurations) and memory consuming, but
  always finds optimal solution and shortest path to it.
</p>

{include "../fig.phtml", "url" => "bfs-animated.gif", "url_thumb" => "bfs-animated_resize.gif", "title" => "Animated BFS, source: <a href=\"http://commons.wikimedia.org/wiki/File:Breadth-First-Search-Algorithm.gif\">commons.wikimedia.org</a>", "fig" => "1"}

<h3 id="depth-first-search">DepthFirstSearch</h3>

<p>
  {javadoc "algorithm.graphsearch.dfs.DepthFirstSearch"} traverses over all possible configurations. First expanded
  configurations are processed last. Is very slow (since it traverses all configurations), but always finds optimal
  solution (however shortest path is not guaranteed).
</p>

{include "../fig.phtml", "url" => "dfs-animated.gif", "url_thumb" => "dfs-animated_resize.gif", "title" => "Animated DFS, source: <a href=\"http://commons.wikimedia.org/wiki/File:Depth-First-Search.gif\">commons.wikimedia.org</a>", "fig" => "2"}

<h3 id="genetic-algorithm">GeneticAlgorithm</h3>

<p>
  {javadoc "algorithm.geneticalgorithm.GeneticAlgorithm"} simulates evolution in nature. Creates population of random configurations and
  then randomly (better configurations has higher chance) selects pair to reproduce into new pair of configurations (to
  next generation). Every optimization step consists of creating whole new population. Common settings for this algorithm are size of
  population and mutation rate. Suggested improvements are implementing new {javadoc "algorithm.geneticalgorithm.Selection"},
  {javadoc "algorithm.geneticalgorithm.Mutation"} and {javadoc "algorithm.geneticalgorithm.Reproduction"} classes.
</p>
<h3 id="graph-search-algorithm">GraphSearch</h3>

<p>
  {javadoc "algorithm.graphsearch.GraphSearch"} algorithm removes much of repetitive work when creating graph search
  algorithms. These usually works almost the same and the only difference is how they store their opened (and closed)
  states (configurations). One optimization step consists of taking one opened configuration, expand it to all nearby
  configurations and put these to opened queue (it is not necessarily a <a href="http://en.wikipedia.org/wiki/First_in,_first_out">FIFO
  queue</a>, it may be any data structure).
</p>

<p>
  How we interact with the queue is defined by {javadoc "algorithm.graphsearch.GraphSearchQueue"} interface. Three most
  important methods are {javadoc "algorithm.graphsearch.GraphSearchQueue#fetch()"} to get new opened state to expand,
  {javadoc "algorithm.graphsearch.GraphSearchQueue#add(cz.cvut.felk.cig.jcop.problem.Configuration)"} to add new state
  to the queue and {javadoc "algorithm.graphsearch.GraphSearchQueue#testPresence(cz.cvut.felk.cig.jcop.problem.Configuration)"}
  to test whether given configuration has ever been added to queue (and hence not to be added again). How these methods
  are implemented alters if search becomes breadth first search, depth first search or some heuristic search for
  example.
</p>

<h3 id="simulated-annealing">SimulatedAnnealing</h3>

<p>
  {javadoc "algorithm.simulatedannealing.SimulatedAnnealing"} works with just one configuration. In every
  optimization step it tries to use a random operation on the configuration. If it leads to better solution or it passes
  the temperature test, it is accepted. Otherwise no change to current configuration is made.
</p>

<p>
  Simulated annealing has starting temperature which lowers in every optimization step by certain amount (both values
  can be changed). The higher the temperature the higher the chance to accept worse configuration and how much worse new
  configuration is also affect chances.
</p>

<p>
  In order for SimulatedAnnealing to be able to work properly, it requires all problems to have their fitness scaled
  to 0.0 - 1.0 (inclusive) interval. See {javadoc "problem.BaseFitness"} for more details.
</p>