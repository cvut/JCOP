{block #title}Stop Conditions{/block}
{block #chapter}D.{/block}
{block #content}

<h3>List of all stop conditions in JCOP</h3>

<p>
  In <a href="#table-1">table 1</a> is a list of all stop conditions bundled with JCOP, along with summary when they are
  met and which messages they accept. Note that all of them extends {javadoc "solver.condition.BaseCondition"}.
</p>

<table class="full" id="table-1">
  <tr>
    <th>Name</th>
    <th>Met</th>
    <th>Accepted messages</th>
  </tr>
  <tr>
    <td><a href="#and-condition">AndCondition</a></td>
    <td>all of its conditions are met</td>
    <td>none</td>
  </tr>
  <tr>
    <td><a href="#found-solution-condition">FoundSolutionCondition</a></td>
    <td>{javadoc "solver.message.MessageSolutionFound"} is received</td>
    <td>{javadoc "solver.message.MessageSolverStart"}<br/>{javadoc "solver.message.MessageSolutionFound"}</td>
  </tr>
  <tr>
    <td><a href="#iteration-condition">IterationCondition</a></td>
    <td>{javadoc "solver.message.MessageOptimize"} is received enough times</td>
    <td>{javadoc "solver.message.MessageSolverStart"}<br/>{javadoc "solver.message.MessageOptimize"}</td>
  </tr>
  <tr>
    <td><a href="#or-condition">OrCondition</a></td>
    <td>any of its conditions is met</td>
    <td>none</td>
  </tr>
  <tr>
    <td><a href="#timeout-condition">TimeoutCondition</a></td>
    <td>CPU time of solver is high enough</td>
    <td>{javadoc "solver.message.MessageSolverStart"}</td>
  </tr>
</table>
<p class="fig-title">Table 1: List of stop conditions in JCOP.</p>

<h3 id="and-condition">AndCondition</h3>

<p>
  {javadoc "solver.condition.AndCondition"} is used to create complex conditions. It can hold any number of stop
  conditions (added in constructor or by calling {javadoc "solver.condition.AndCondition#addStopCondition(cz.cvut.felk.cig.jcop.solver.condition.StopCondition)"}).
  Whenever it is evaluated, returns true iff no stop condition in it returned false. It accepts no messages.
</p>

<h3 id="found-solution-condition">FoundSolutionCondition</h3>

<p>
  {javadoc "solver.condition.FoundSolutionCondition"} returns true at least one solution was found (solution is such
  configuration for which {javadoc "problem.Problem#isSolution(cz.cvut.felk.cig.jcop.problem.Configuration)"}
  returns true). It accepts {javadoc "solver.message.MessageSolverStart"} to reset it internal status and
  {javadoc "solver.message.MessageSolutionFound"} to notify that solution was found.
</p>

<h3 id="iteration-condition">IterationCondition</h3>

<p>
  {javadoc "solver.condition.IterationCondition"} counts number of optimizations in solver iteration. When a threshold
  specified in constructor is achieved, it returns true. Accepts {javadoc "solver.message.MessageOptimize"}
  to increase internal optimization counter and {javadoc "solver.message.MessageSolverStart"} to reset it to zero.
</p>

<h3 id="or-condition">OrCondition</h3>

<p>
  {javadoc "solver.condition.OrCondition"} is used to create complex conditions. It can hold any number of stop
  conditions (added in constructor or by calling {javadoc "solver.condition.OrCondition#addStopCondition(cz.cvut.felk.cig.jcop.solver.condition.StopCondition)"}).
  Whenever it is evaluated, returns true iff at least one stop condition in it returned true. It accepts no messages.
</p>

<h3 id="timeout-condition">TimeoutCondition</h3>

<p>
  {javadoc "solver.condition.TimeoutCondition"} limits how long can one solver iteration run. Limit time in miliseconds
  is given in constructor. Uses {javadoc "util.PreciseTime#getCpuTimeMili()"} to get CPU time. Returns true after
  specified time has elapsed. Accepts {javadoc "solver.message.MessageSolverStart"} to reset timer.
</p>