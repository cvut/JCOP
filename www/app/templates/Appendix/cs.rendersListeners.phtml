{block #title}Rendery, Listenery{/block}
{block #chapter}E.{/block}
{block #content}

<h3>Seznam všech renderů a listenerů v JCOPu</h3>

<p>
  V <a href="#table-1">tabulce 1</a> je seznam všech renderů (vykreslovačů) a listenerů dodávaných společně s JCOPem.
  Ke každému je cílový výstup, typ (render nebo listener) a jak popis jak formátuje výsutp.
</p>

<table class="full" id="table-1">
  <tr>
    <th>Název</th>
    <th>Typ</th>
    <th>Popis formátu</th>
    <th>Výstup</th>
  </tr>
  <tr>
    <td><a href="#csv-render">CSVRender</a></td>
    <td>Render</td>
    <td>Vytvoří <abbr title="Comma-separated values">CSV</abbr> soubor pomocí <a href="http://sourceforge.net/projects/javacsv/">JavaCSV</a>
    knihovny.</td>
    <td>
      <a href="http://java.sun.com/javase/6/docs/api/java/io/OutputStream.html">java.io.OutputStream</a><br />
      <a href="http://java.sun.com/javase/6/docs/api/java/io/File.html">java.io.File</a><br />
      <a href="http://java.sun.com/javase/6/docs/api/java/lang/System.html#out">System.out</a> (konzole)
    </td>
  </tr>
  <tr>
    <td><a href="#exception-render">ExceptionRender</a></td>
    <td>Render</td>
    <td>Vypíše pouze výjimky pro každý result, ale s jejich celým stack trace.</td>
    <td>
      <a href="http://java.sun.com/javase/6/docs/api/java/lang/System.html#out">System.out</a> (konzole)
    </td>
  </tr>
  <tr>
    <td><a href="#jfree-chart-render">JFreeChartRender</a></td>
    <td>Listener</td>
    <td>Vytvoří graf s výsledky, které se za běhu samy aktualizují. Každá iterace solveru má vlastní křivku v grafu..</td>
    <td>
      <a href="http://java.sun.com/javase/6/docs/api/javax/swing/JFrame.html">JFrame</a>
    </td>
  </tr>
  <tr>
    <td><a href="#simple-compare-render">SimpleCompareRender</a></td>
    <td>Render</td>
    <td>
      Seřadí výsledky podle fitness (sestupně) a podle počtu optimalizací (vzestupně), které poté vykreslí do dvou
      tabulek. Každá má problém, algoritmus a poté buď fitness nebo počet optimalizací. Užitečné pro rychlé porovnání
      více různých algoritmů/nastavení jednoho.
    </td>
    <td>
      <a href="http://java.sun.com/javase/6/docs/api/java/io/PrintStream.html">java.io.PrintStream</a><br />
      <a href="http://java.sun.com/javase/6/docs/api/java/io/File.html">java.io.File</a><br />
      <a href="http://java.sun.com/javase/6/docs/api/java/lang/System.html#out">System.out</a> (konzole)
    </td>
  </tr>
  <tr>
    <td><a href="#simple-render">SimpleRender</a></td>
    <td>Render</td>
    <td>
      Vypisuje textové informace o záznamech výsledku při různých úrovní detailnosti.
    </td>
    <td>
      <a href="http://java.sun.com/javase/6/docs/api/java/io/PrintStream.html">java.io.PrintStream</a><br />
      <a href="http://java.sun.com/javase/6/docs/api/java/io/File.html">java.io.File</a><br />
      <a href="http://java.sun.com/javase/6/docs/api/java/lang/System.html#out">System.out</a> (konzole)
    </td>
  </tr>
  <tr>
    <td><a href="#xml-render">XMLRender</a></td>
    <td>Render</td>
    <td>
      Vytvoří XML soubor s detailními informacemi o každém záznamu výsledku.
    </td>
    <td>
      <a href="http://java.sun.com/javase/6/docs/api/java/io/File.html">java.io.File</a>
    </td>
  </tr>
</table>
<p class="fig-title">Table 1: Seznam všech renderů a listenerů v JCOPu.</p>

<h3 id="csv-render">CSVRender</h3>

<p>
  {javadoc "result.render.CSVRender"} vytvoří CSV výstup, první řádka obsahuje hlavičky a poté je pro každý záznam
  výsledku jedna řádka. CSVRender ve výchozím nastavení používá čárku jako oddělovač a utf-8 kódování, které obojí jsou
  nekompatibilní s Microsoft Office Excelem. Je možné pomocí {javadoc "result.render.CSVRender#setCharset(java.nio.charset.Charset)"}
  a {javadoc "result.render.CSVRender#setDelimiter(char)"} oddělovač i kódování změnit. Dále je nutné dbát na to, že
  dokonce ani <a href="http://www.openoffice.org/">Open Office</a> neumožňuje mít více jak 1024 sloupců (Microsoft Office Excel 2003
  má pouze 256, Microsoft Office Excel 2007 by měl zvládat přečíst okolo 15681 sloupců) a tudíž historie operací může
  být oříznuta. Na obrázku <a href="#fig1">figure 1</a> je demonstrace výstupu.
</p>

{include "../fig.phtml", "url" => "csv-output.png", "url_thumb" => "csv-output_resize.png", "title" => "Výstup CSVRender otevřený v Open Office Calc", "fig" => "1"}

<p>
  Následuje příklad použití {javadoc "result.render.CSVRender"}:
</p>

<pre class="brush: java;">
Solver solver = /* ... */

// Output to System.out
solver.addRender(new CSVRender());

// Output to file
solver.addRender(new CSVRender(new File("output-file.csv")));

// Output to directly specified OutputStream
solver.addRender(new CSVRender(System.out));

// ISO-8859-1 charset, ';' delimiter
CSVRender csvRender = new CSVRender();
csvRender.setDelimiter(';');
csvRender.setCharset(Charset.forName("ISO-8859-1"));
</pre>

<h3 id="exception-render">ExceptionRender</h3>

<p>
  {javadoc "result.render.ExceptionRender"} vypisuje pouze informace o výjimce, pokud nějaká nastala. Zapisuje do
  konzole a vypisuje celou stack trace pomocí<a href="http://java.sun.com/javase/6/docs/api/java/lang/Throwable.html#printStackTrace()">
  Throwable#printStackTrace()</a>. Na příkladu Example 1 je vidět výstup ExceptionRender.
</p>

<pre class="brush: plain;">
Problem Knapsack [line=9000 4 100 18 114 42 136 88 192 3 223]/Algorithm BreadthFirstSearch [] got Exception CannotContinueException
cz.cvut.felk.cig.jcop.algorithm.CannotContinueException: No more items in queue
	at cz.cvut.felk.cig.jcop.algorithm.graphsearch.GraphSearch.optimize(GraphSearch.java:44)
	at cz.cvut.felk.cig.jcop.solver.BaseSolver.optimize(BaseSolver.java:160)
	at cz.cvut.felk.cig.jcop.solver.SimpleSolver.run(SimpleSolver.java:44)
	at demopackage.DemoTemp.main(DemoTemp.java:135)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:110)
</pre>
<p class="fig-title">Example 1: {javadoc "result.render.ExceptionRender"} zobrazující výjimku v BFS při řešení problému batohu.</p>

<p>
  Použití ExceptionRender je následovné:
</p>

<pre class="brush: java;">
Solver solver = /* ... */

solver.addRender(new ExceptionRender());
</pre>

<h3 id="jfree-chart-render">JFreeChartRender</h3>

<p>
  {javadoc "result.render.JFreeChartRender"} se přidává jako listener do {javadoc "solver.Solver"}, aby byl schopen
  zaregistrovat každou změnu nejlepšího řešení. Pokud je nějaké nalezeno (zpráva {javadoc "solver.message.MessageBetterConfigurationFound"}),
  JFreeChartRender přidá jeden bod do grafu. Každá iterace solveru má vlastní křivku v grafu, osa X značí počet
  optimalizací, kdy bylo řešení nalezeno, a osa Y fitness nejlepšího řešení. {javadoc "result.render.JFreeChartRender"}
  používá knihovnu <a href="http://www.jfree.org/jfreechart/">JFreeChart</a>. Na obrázku <a href="#fig2">figure 2</a>
  je vidět jako jeho výstup může vypadat.
</p>

{include "../fig.phtml", "url" => "jfreechart-output.png", "url_thumb" => "jfreechart-output_resize.png", "title" => "JFreeChartRender output when benchmarking 10 settings of Simulated Annealing on SAT problem", "fig" => "2"}

<p>
  {javadoc "result.render.JFreeChartRender"} vyžaduje pouze parametr <code>title</code> a jeho použití může být zapsáno
  takto:
</p>

<pre class="brush: java;">
Solver solver = /* ... */

solver.addListener(new JFreeChartRender("Demo JFreeChartRender"));
</pre>

<h3 id="simple-compare-render">SimpleCompareRender</h3>

<p>
  {javadoc "result.render.SimpleCompareRender"} slouží k rychlému porovnání výsledků podle jejich fitness (kvality
  řešení) a počtu optimalizací (rychlosti procházení stavového prostoru). Toto je užitečné pokud chcete na první pohled
  vidět, který algoritmus (nebo problém) si počínal lépe a který hůře. Výsledek může být zapsán do konzole,
  <a href="http://java.sun.com/javase/6/docs/api/java/io/File.html">java.io.File</a> (souboru) nebo libovolného
  <a href="http://java.sun.com/javase/6/docs/api/java/io/PrintStream.html">java.io.PrintStream</a>. Výsledek vypadá jako tabulka,
  jedna řazená dle fitness, druhá podle počtu optimalizací. V příkladu Example 2 je ukázkový výstup.
</p>

<pre class="brush: plain;">
Results sorted by fitness (DESC):
fitness    algorithm                               problem
7,0        SimulatedAnnealing [T=10.0, A=0.9]      SAT [valid-standard.cnf]
-2,0       SimulatedAnnealing [T=10.0, A=0.999]    SAT [valid-standard.cnf]
-3,0       BreadthFirstSearch []                   SAT [valid-standard.cnf]
-3,0       SimulatedAnnealing [T=100.0, A=0.999]   SAT [valid-standard.cnf]
-4,0       DepthFirstSearch []                     SAT [valid-standard.cnf]

Results sorted by optimizations (ASC):
optimiz.   algorithm                               problem
725        BreadthFirstSearch []                   SAT [valid-standard.cnf]
756        DepthFirstSearch []                     SAT [valid-standard.cnf]
2981       SimulatedAnnealing [T=10.0, A=0.999]    SAT [valid-standard.cnf]
3636       SimulatedAnnealing [T=10.0, A=0.9]      SAT [valid-standard.cnf]
3930       SimulatedAnnealing [T=100.0, A=0.999]   SAT [valid-standard.cnf]
</pre>
<p class="fig-title">Example 2: {javadoc "result.render.SimpleCompareRender"} renderuje použití různých algoritmů na SAT problému po dobu 100ms.</p>

<p>
  {javadoc "result.render.SimpleCompareRender"} lze přidat do solveru tímto způsobem:
</p>

<pre class="brush: java;">
Solver solver = /* ... */

// Output to console
solver.addRender(new SimpleCompareRender());

// Output to file
solver.addRender(new SimpleCompareRender(new File("output-file.txt")));

// Output to directly specified PrintStream
solver.addRender(new SimpleCompareRender(System.out));
</pre>

<h3 id="simple-render">SimpleRender</h3>

<p>
  {javadoc "result.render.SimpleRender"} je základním renderem JCOPu. Poskytuje výstup jak do konzole,
  <a href="http://java.sun.com/javase/6/docs/api/java/io/File.html">java.io.File</a> (souboru) nebo libovolného jiného
  <a href="http://java.sun.com/javase/6/docs/api/java/io/PrintStream.html">java.io.PrintStream</a>. Má tři úrovně
  detailnosti onformací, {javadoc "result.render.SimpleRender#OUTPUT_STANDARD"} (vypisuje téměř vše kromě historie
  operací), {javadoc "result.render.SimpleRender#OUTPUT_MINI"} (vypisuje pouze čas, počet optimalizací, fitness, výjimku
  a nejlepší řešení) a {javadoc "result.render.SimpleRender#OUTPUT_FULL"} (vypisuje téměř vše, včetně historie operací).
  V Example 3, 4 a 5 jsou vidět ukázky všech tří úrovní.
</p>

<pre class="brush: plain;">
=== Algorithm DepthFirstSearch [] used on problem SAT [valid-standard.cnf] ===
  CPU Time:                     110 [ms]
  System Time:                    1 [ms]
  User Time:                    109 [ms]
  Clock Time:                   125 [ms]
  Optimize counter:             511 [-]
  Optimize/sec (CPU):          4645 [1/s]
  Optimize/sec (Clock):        4088 [1/s]
  Best solution:         Configuration{!="{"}attributes=[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1], operationHistory={!="{"}247 items}}
  Depth:                        247 [-]
  Fitness:                     -4,0 [-]
  Ended without exception
</pre>
<p class="fig-title">Example 3: {javadoc "result.render.SimpleRender"} s úrovní výstupu {javadoc "result.render.SimpleRender#OUTPUT_STANDARD"} renderuje DFS použitém na SATu s 100ms timeoutem.</p>

<pre class="brush: plain;">
=== (DepthFirstSearch [], SAT [valid-standard.cnf]) ===
  CPU Time:     110 ms. Optimizations:     511. Fitness:    -4,0. Best solution: Configuration{!="{"}attributes=[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1], operationHistory={!="{"}247 items}}. Ended without exception.
</pre>
<p class="fig-title">Example 4: {javadoc "result.render.SimpleRender"} s úrovní výstupu {javadoc "result.render.SimpleRender#OUTPUT_MINI"} renderuje DFS použitém na SATu s 100ms timeoutem.</p>

<pre class="brush: plain;">

=== Algorithm DepthFirstSearch [] used on problem SAT [valid-standard.cnf] ===
  CPU Time:                     110 [ms]
  System Time:                    1 [ms]
  User Time:                    109 [ms]
  Clock Time:                   125 [ms]
  Optimize counter:             511 [-]
  Optimize/sec (CPU):          4645 [1/s]
  Optimize/sec (Clock):        4088 [1/s]
  Best solution: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1]
  Depth:                        247 [-]
  Fitness:                     -4,0 [-]
  Operation history:
           0. Empty SAT created
           1. SetTrueOperation{!="{"}index=19}
           2. SetTrueOperation{!="{"}index=18}
           3. SetTrueOperation{!="{"}index=17}
           4. SetFalseOperation{!="{"}index=19}
           5. SetTrueOperation{!="{"}index=16}
           ... ... ...
</pre>
<p class="fig-title">Example 5: {javadoc "result.render.SimpleRender"} s úrovní výstupu {javadoc "result.render.SimpleRender#OUTPUT_FULL"} renderuje DFS použitém na SATu s 100ms timeoutem.</p>

<p>
  {javadoc "result.render.SimpleRender"} můžete do solveru přidat tímto způsobem:
</p>

<pre class="brush: java;">
Solver solver = /* ... */

// Output standard info to console
solver.addRender(new SimpleRender(SimpleRender.OUTPUT_STANDARD));

// Output minimal info to specified PrintStream
solver.addRender(new SimpleRender(SimpleRender.OUTPUT_MINI, System.out));

// Output full into to file
solver.addRender(new SimpleRender(SimpleRender.OUTPUT_FULL, new File("output-file.txt")));
</pre>

<h3 id="xml-render">XMLRender</h3>

<p>
  {javadoc "result.render.XMLRender"} vytváří XML soubory, ve kterých jsou všechny dostupné informace o výsledku. Toto
  je vhodné pro automatické zpracování díky snadnému čtení XML souborů. Vyžaduje <a href="http://java.sun.com/javase/6/docs/api/java/io/File.html">java.io.File</a>
  do kterého má zapisovat. Níže je ukázka XML souboru (přeformátována pro snazší čtení).
</p>

<pre class="brush: xml;">
&lt;?xml version="1.0" standalone="yes"?&gt;
&lt;result&gt;
  &lt;experiment date='Wed Mar 17 16:47:11 CET 2010'&gt;&lt;/experiment&gt;
  &lt;entry exception='CannotContinueException' clock-time='16' system-time='1' user-time='16' algorithm='BreadthFirstSearch []' cpu-time='15' optimize-counter='16' problem='Knapsack [line=9000 4 100 18 114 42 136 88 192 3 223]'&gt;
    &lt;best-solution fitness='473.0'&gt;
      &lt;operations&gt;
        &lt;operation index='0' label='Empty knapsack created'&gt;&lt;/operation&gt;
        &lt;operation index='1' label='AddOperation{!="{"}knapsackItem=KnapsackItem{!="{"}index=0, weight=18, price=114}}'&gt;&lt;/operation&gt;
        &lt;operation index='2' label='AddOperation{!="{"}knapsackItem=KnapsackItem{!="{"}index=1, weight=42, price=136}}'&gt;&lt;/operation&gt;
        &lt;operation index='3' label='AddOperation{!="{"}knapsackItem=KnapsackItem{!="{"}index=3, weight=3, price=223}}'&gt;&lt;/operation&gt;
      &lt;/operations&gt;
      &lt;attributes&gt;
        &lt;attribute index='0' value='1' human-readable-value='1'&gt;&lt;/attribute&gt;
        &lt;attribute index='1' value='1' human-readable-value='1'&gt;&lt;/attribute&gt;
        &lt;attribute index='2' value='0' human-readable-value='0'&gt;&lt;/attribute&gt;
        &lt;attribute index='3' value='1' human-readable-value='1'&gt;&lt;/attribute&gt;
      &lt;/attributes&gt;
    &lt;/best-solution&gt;
  &lt;/entry&gt;
&lt;/result&gt;
</pre>
<p class="fig-title">Example 6: {javadoc "result.render.XMLRender"} vytvořil XML soubor pro BFS algoritmus použitý na problému batohu.</p>

<p>
  {javadoc "result.render.XMLRender"} se přidává do solvera následovně:
</p>

<pre class="brush: java;">
Solver solver = /* ... */

solver.addRender(new XMLRender(new File("output-file.xml")));
</pre>