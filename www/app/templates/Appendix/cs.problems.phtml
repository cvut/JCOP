{block #title}Problémy{/block}
{block #chapter}C.{/block}
{block #content}

<h3>Seznam všech problémů v JCOPu</h3>

<p>
  V <a href="#table-1">tabulce 1</a> je seznam všech problémů dodávaných společně s JCOPem, společně s krátkým popisem
  a implementovanými rozhraními.
</p>

<table class="full" id="table-1">
  <tr>
    <th>Název</th>
    <th>Popis</th>
    <th>Implementovaná rozhraní</th>
  </tr>
  <tr>
    <td><a href="#bucket">Bucket</a></td>
    <td>Problém kýblů má zadaný konečný počet kýblů (kapacitu a počáteční obsah) a cílem je mít v každém kýblu zadané
    (cílové) množství. Vodu lze mezi kýbly přelévat, kýbl lze naplnit na maximum a vylít.</td>
    <td>
      {javadoc "problem.Problem"}<br />
      {javadoc "problem.DestinationProblem"}<br />
      {javadoc "problem.StartingConfigurationProblem"}
    </td>
  </tr>
  <tr>
    <td><a href="#job-shop">JobShop</a></td>
    <td>Naplánovat <code>n</code> různých úkolů (každý se zadanou délkou trvání) na <code>n</code> (<code>m</code> &lt;
    <code>n</code>) identických strojů, který každý zvládne provádět jednu operaci v jednom okamžiku. Cílem je najít
    takové přiřazení úkolů na stroje, aby celkový čas byl minimální.</td>
    <td>
      {javadoc "problem.Problem"}<br />
      {javadoc "problem.StartingConfigurationProblem"}<br />
      {javadoc "problem.RandomConfigurationProblem"}<br />
      {javadoc "problem.GlobalSearchProblem"}
    </td>
  </tr>
  <tr>
    <td><a href="#knapsack">Knapsack</a></td>
    <td>Přidáváte věci se zadanou hmotností a cenou do batohu, který má ale omezenou nosnost. Maximalizujte celkovou
    cenu věcí v nepřetíženém batohu.</td>
    <td>
      {javadoc "problem.Problem"}<br />
      {javadoc "problem.StartingConfigurationProblem"}<br />
      {javadoc "problem.RandomConfigurationProblem"}<br />
      {javadoc "problem.GlobalSearchProblem"}
    </td>
  </tr>
  <tr>
    <td><a href="#sat">SAT</a></td>
    <td>Přiřaďte logické hodnoty (pravda, lež) proměnným (každá má zadanou hmotnost) tak, aby daná formule byla vyhodnocena
    jako pravda. Minimalizujte hmotnost proměnných, které mají přiřazenou hodnotu pravda.</td>
    <td>
      {javadoc "problem.Problem"}<br />
      {javadoc "problem.StartingConfigurationProblem"}<br />
      {javadoc "problem.RandomConfigurationProblem"}<br />
      {javadoc "problem.GlobalSearchProblem"}
    </td>
  </tr>
  <tr>
    <td><a href="#tsp">TSP</a></td>
    <td>Najděte pořadí ve kterém projít seznam měst (každé má zadanou vzdálenost do všech ostatních) takové, že každé
    město je navštíveno právě jednou a celková délka cesty je minimální.</td>
    <td>
      {javadoc "problem.Problem"}<br />
      {javadoc "problem.StartingConfigurationProblem"}
    </td>
  </tr>
</table>

<p class="fig-title">Table 1: Seznam všech problémů v JCOPu.</p>

<h3 id="bucket">Bucket</h3>

<p>
  {javadoc "problem.bucket.Bucket"} (problém přelévání kýblů) začíná s množinou <code>n</code> kýblů, každý se zadanou
  kapacitou a obsahem. Cílem je v každém kýblu mít zadaný cílový obsah. Povolené operace jsou naplnění kýble na maximum,
  vylití kýble a přelití jednoho kýble do druhého (pokud v druhém není dost místa, zbytek zůstává v první kýbli).
</p>

<p>
  Tento probleém se inicializuje pomocí polí integerů, viz níže.
</p>

<pre class="brush: java;">
Bucket bucket = new Bucket(new int[]{!="{"}14, 10, 6, 2, 8}, new int[]{!="{"}0, 0, 1, 0, 0}, new int[]{!="{"}12, 6, 4, 1, 8});
</pre>

<p>
  Tímto je vytvořen problém 5 kýblů, s objemy 14, 10, 6, 2 a 8, počátačním obsahem 0, 0, 1, 0, 0 a cílovým obsahem 12,
  6, 4, 1, 8. Nejlepší řešení pro tyto parametry je (Nalít 2 do 0, Naplnit 1, Nalít 1 do 2, Nalít 2 do
  4, Naplnit 2, Nalít 2 do 3, Nalít 3 do 1, Nalít 0 do 3, Naplnit 0, Nalít 0 do 4), kde čísla jsou indexy kýblů
  (indexováno od 0).
</p>

<p>
  Tři definované operace jsou {javadoc "problem.bucket.FillOperation"} (naplní kýbl po okraj), {javadoc "problem.bucket.SpillOperation"}
  (vyprázdní kýbl) a {javadoc "problem.bucket.PourOperation"} (přelije obsah kýble do jiného). Výchozí fitness {javadoc "problem.bucket.BucketFitness"}
  vrací hodnoty od 0 do<code>n</code>, kde číslo udává počet kýblů, které mají cílový obsah. Konfigurace má <code>n</code>
  proměnných, každá reprezentující kapacitu jednoho kýble.
</p>

<h3 id="job-shop">JobShop</h3>

<p>
  {javadoc "problem.jobshop.JobShop"} je problém, kde je třeba přiřadit <code>n</code> úkolům (každý s danou délkou
  trvání), na kterém z <code>m</code> identických strojů poběží. Cílem je minimalizovat celkové trvání.
</p>

<p>
  JobShop je inicializován pomocí seznamu integerů (prvání úkolů) a počtu strojů. Ukázka viz níže.
</p>

<pre class="brush: java;">
List&lt;Integer&gt; jobs = new ArrayList&lt;Integer&gt;(5);
jobs.add(5);
jobs.add(4);
jobs.add(6);
jobs.add(2);
jobs.add(2);
JobShop jobShop = new JobShop(jobs, 3);
</pre>

<p>
  Toto vytvoří JobShop s 5 úkoly (trvání 5, 4, 6, 2 a 2) a 3 stroji. Nejlepší řešení je mít úkoly 1 a 4 na stroji 0,
  úkoly 0 a 3 na stroji 1 a úkol 2 na stroji 2. Celkový čas je 7.
</p>

<p>
  Jediná operace je {javadoc "problem.jobshop.MoveOperation"}, která přesune úkol z jednoho stroje na druhý. Výchozí
  fitness je {javadoc "problem.jobshop.JobShopFitness"} a je vypočítána tak, že pokud by všechny úkoly běžely na jednom
  stroji, je výsledek 0. Za každou ušetřenou jednotku času je fitness o 1 vyšší. Konfigurace má <code>n</code>
  proměnných, každá reprezentující na kterém stroji daná úloha běží.
</p>

<h3 id="knapsack">Knapsack</h3>

<p>
  V {javadoc "problem.knapsack.Knapsack"} (problém batohu) je zadaných <code>n</code> věcí (každá má svou hmotnost a cenu
  a je reprezentována pomocí {javadoc "problem.knapsack.KnapsackItem"}) a batoh dané nosnosti. Potřebujeme do batohu dát
  tak věci, že celková hmotnost neni vyšší než nosnost batohu a zároveň celková cena věcí v batohu je maximální.
</p>

<p>
  Knapsack se inicializuje buď ze souboru nebo řetězce. Obojí používá stejný formát, v případě souboru se buď vezme
  první řádek nebo řádek s id zadaném v konstruktoru. První číslo v řádku je id, druhé počet věcí, třetí kapacita.
  Následují dvojice hmotnost-cena pro každou věci. Níže je ukázka načítání ze souboru.
</p>

<pre class="brush: java;">
Knapsack knapsack = new Knapsack("9000 4 100 18 114 42 136 88 192 3 223");
</pre>

<p>
  Toto vytvoří Knapsack s 4 věcmi (vážicí 18, 42, 88 a 8, s cenami 114, 136, 192, 223), id problému je 9000 a batoh má
  kapacitu 100. Nejlepší řešení je mít věci 0, 1 a 3 v batohu (celková hmotnost 63, celková cena 473). 
</p>

<p>
  Dvě poskytované operace jsou {javadoc "problem.knapsack.AddOperation"} (přidá věc do batohu) a {javadoc "problem.knapsack.RemoveOperation"}
  (odebere věc z batohu). Výchozí fitness je {javadoc "problem.knapsack.KnapsackFitness"} a funguje tak, že přetížený
  batoh vrací záporné číslo (vyšší celková cena znamená vyšší fitness). Pokud hmotnost věcí nepřesahuje nosnost, fitness
  je kladná a rovna celkové ceně věcí v batohu. Konfigurace má jednu proměnnou pro každou věc, hodnota 0 znamená že věc
  v batohu není, 1 že věc v batohu je.
</p>

<h3 id="sat">SAT</h3>

<p>
  {javadoc "problem.sat.SAT"} problém má na vstupu <code>n</code> proměnných (každá s danou hmotností) a jednu formuli
  (ve tvaru součin součtů). Cílem je přiřadit každé proměnné logickou hodnotu pravda nebo lež tak, aby formule byla
  vyhodnocena jako pravda a zároveň celková hmotnost proměnných ohodnocených jako true byla minimální.
</p>

<p>
  SAT se načítá ze souboru (jeho formát viz {javadoc "problem.sat.SAT#SAT(java.io.File)"}). Vytvoří <code>n</code>
  proměnných a <code>m</code> klauzulí. V každé klauzuli je libovolný počet (obvykle 3 jako u 3-SAT problému) proměnných,
  které mohou být negovány. Níže je příklad načtení ze souboru:
</p>

<pre class="brush: java;">
SAT sat = new SAT(new File("data/sat/easy.cnf"));
</pre>

<p>
  Tímto je vytvořen SAt ze souboru <code>data/sat/easy.cnf</code>.
</p>

<p>
  V tomto problému jsou dvě operace - {javadoc "problem.sat.SetTrueOperation"} (nastaví proměnnou na pravda) a {javadoc "problem.sat.SetFalseOperation"}
  (nastaví hodnotu na lež). Výchozí fitness je {javadoc "problem.sat.SATFitness"}, která se spočítá tak, že pokud je
  formule splněna, fitness je kladné číslo (vyšší hmotnost znamená nižší cenu). Pokud formule splněna není, fitness je
  negativní počet nesplněných klauzulí. Konfigurace má <code>n</code> proměnných, každá buď 0 (proměnná je lež) neb 1
  (proměnná je pravda).
</p>

<h3 id="tsp">TSP</h3>

<p>
  {javadoc "problem.tsp.TSP"} (problém obchodního cestujícího) je definován pomocí <code>n</code> měst a délkou cesty
  z libovolného města do jiného. Úkolem je najít takovou cestu, že každé město bude navštíveno právě jednou a celková
  délka cesty je minimální (také známo pod názvem <a href="http://cs.wikipedia.org/wiki/Hamiltonovská_kružnice#Hamiltonovsk.C3.A1_kru.C5.BEnice">Hamiltonovská kružnice</a>).
</p>

<p>
  TSP se načítá pomocí 2D pole Integerů - čtvercová matice vzdáleností (umožňující asymetrické TSP). Pro každý řádek
  v matici, jedno {javadoc "problem.tsp.City"} (město) je vytvořeno s Mapou vzdáleností do ostatních měst. Níže je
  ukázka jak načíst TSP z 2D pole:
</p>

<pre class="brush: java;">
TSP tsp = new TSP(new Integer[][]{!="{"}
        {!="{"} 0, 20, 42, 35},
        {!="{"}20,  0, 30, 34},
        {!="{"}42, 30,  0, 53},
        {!="{"}35, 34, 53,  0},
});
</pre>

<p>
  Toto vytvoří TSP se 4 městy. Vzdálenost z prvního do druhého je 20, z prvního do třetího 42 atd. Nejlepší řešení je
  navštívit města v pořadí město 2, město 1, město 0 a město 3. Celková vzdálenost je poté.
</p>

<p>
  Jediná operace v TSP je {javadoc "problem.tsp.SwitchCityOperation"}, která prohodí dvě města na cestě (například pokud
  město A mělo být navštíveno jako k-té a město B jako j-té, tak po provedení operace je město A navštíveno jako j-té a
  město B jako k-té). Výchozí fitness je {javadoc "problem.tsp.TSPFitness"}, jeho hodnota je buď negativní číslo
  odpovídající celkové délce cesty (pokud konfigurace obsahuje neplatnou cestu) nebo pozitivní číslo takové, že kratší
  cesta značí vyšší fitness. Konfigurace má <code>n</code> proměnných, indexy jsou pozice v cestě a hodnoty jsou čísla
  měst. Například konfigurace [2,3,1,0] by znamenala navštívení měst v pořadí 2. město, 3. město, 1. město a nakonec
  město s indexem 0.
</p>