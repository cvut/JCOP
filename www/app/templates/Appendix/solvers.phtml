{block #title}Solvers{/block}
{block #chapter}A.{/block}
{block #content}

<h3>List of all solvers in JCOP</h3>

<p>
  In <a href="#table-1">table 1</a> is a list of all solvers bundled with JCOP, along with brief description and default
  registered renders apart from {javadoc "result.render.SimpleRender"} (which is registered as default to all solvers).
  Note that all of them extends {javadoc "solver.BaseSolver"}.
</p>

<table class="full" id="table-1">
  <tr>
    <th>Name</th>
    <th>Description</th>
    <th>Additional Renders</th>
  </tr>
  <tr>
    <td><a href="#algorithm-compare-solver">AlgorithmCompareSolver</a></td>
    <td>Runs several algorithms on one problem.</td>
    <td>{javadoc "result.render.SimpleCompareRender"}</td>
  </tr>
  <tr>
    <td><a href="#median-solver">MedianSolver</a></td>
    <td>Wraps around another solver, runs it several times and returns median from its results.</td>
    <td>{javadoc "result.render.SimpleCompareRender"}</td>
  </tr>
  <tr>
    <td><a href="#multi-solver">MultiSolver</a></td>
    <td>Makes cartesian product of given algorithms and problems and runs all of them.</td>
    <td>{javadoc "result.render.SimpleCompareRender"}</td>
  </tr>
  <tr>
    <td><a href="#problem-compare-solver">ProblemCompareSolver</a></td>
    <td>Runs one algorithm on several problems.</td>
    <td>{javadoc "result.render.SimpleCompareRender"}</td>
  </tr>
  <tr>
    <td><a href="#simple-solver">SimpleSolver</a></td>
    <td>Runs one algorithm on one problem.</td>
    <td>none</td>
  </tr>
</table>
<p class="fig-title">Table 1: List of solvers in JCOP.</p>

<h3 id="algorithm-compare-solver">AlgorithmCompareSolver</h3>

<p>
  {javadoc "solver.AlgorithmCompareSolver"} is created with one problem and multiple algorithms. More algorithms can be
  added by {javadoc "solver.AlgorithmCompareSolver#addAlgorithm(cz.cvut.felk.cig.jcop.algorithm.Algorithm)"}. Solver
  uses every algorithm in turn on supplied problem. Has default renders {javadoc "result.render.SimpleRender"} and
  {javadoc "result.render.SimpleCompareRender"}.
</p>

<h3 id="median-solver">MedianSolver</h3>

<p>
  {javadoc "solver.MedianSolver"} is very different from other solvers. It cannot solve itself, but takes another solver
  and runs it repeatedly, storing results from every run. After that, it makes median from results (results ordered by
  best fitness) and presents it as a result. This solver is very useful when you have random-based algorithm and want to
  eliminate statistical errors.
</p>

<p>
  Note that if wrapped solver returns more than one result entry in its result, median requires that in every run solver
  returns same number of result entries and in same order. 
</p>

<p>
  {javadoc "solver.MedianSolver"} has default renders {javadoc "result.render.SimpleRender"} and
  {javadoc "result.render.SimpleCompareRender"}.
</p>

<h3 id="multi-solver">MultiSolver</h3>

<p>
  {javadoc "solver.MultiSolver"} is created with a list of problems and list of algorithms. More algorithms and problems
  can be added by {javadoc "solver.MultiSolver#addAlgorithm(cz.cvut.felk.cig.jcop.algorithm.Algorithm)"} and
  {javadoc "solver.MultiSolver#addProblem(cz.cvut.felk.cig.jcop.problem.Problem)"}. Solver makes cartesian product, eg.
  applies every algorithm on every problem in turn. Has default renders {javadoc "result.render.SimpleRender"} and
  {javadoc "result.render.SimpleCompareRender"}.
</p>

<h3 id="problem-compare-solver">ProblemCompareSolver</h3>

<p>
  {javadoc "solver.ProblemCompareSolver"} is created with one algorithm and multiple problems. More problems can be
  added by {javadoc "solver.ProblemCompareSolver#addProblem(cz.cvut.felk.cig.jcop.problem.Problem)"}. Solver
  uses supplied algorithm on every problem in turn. Has default renders {javadoc "result.render.SimpleRender"} and
  {javadoc "result.render.SimpleCompareRender"}.
</p>

<h3 id="simple-solver">SimpleSolver</h3>

<p>
  {javadoc "solver.SimpleSolver"} is useful for simple testing if algorithm or problem works. Takes only single
  algorithm and single problem and makes one solver iteration. Has default render {javadoc "result.render.SimpleRender"}.
</p>