{block #title}Algoritmy{/block}
{block #chapter}B.{/block}
{block #content}

<h3>Seznam všech algoritmů v JCOPu</h3>

<p>
  V <a href="#table-1">tabulce 1</a> je seznam všech algoritmů dodávaných společně s JCOPem, jejich krátký popis, typ
  prohledávání a jaká vyžaduje rozhraní. Oba zde uvedené algoritmy na grafové prohledávání jsou potomky abstraktního
  algoritmu {javadoc "algorithm.graphsearch.GraphSearch"}, který snižuje množství opakujícího se kódu při tvorbě
  nových algoritmů na pouhé vytvoření fronty pro daný algoritmus.
</p>

<table class="full" id="table-1">
  <tr>
    <th>Jméno</th>
    <th>Popis</th>
    <th>Typ prohledávání</th>
    <th>Požadovaná rozhraní</th>
  </tr>
  <tr>
    <td><a href="#breadth-first-search">BreadthFirstSearch</a><br />(prohledávání&nbsp;do&nbsp;šířky)</td>
    <td>Grafové prohledávání, kde nově expandované elementy se dávají na konec fronty. Pomalý a paměťově náročný algoritmus,
    který ale zaručuje nalezení optimálního řešení.</td>
    <td>Grafové</td>
    <td>{javadoc "problem.StartingConfigurationProblem"}</td>
  </tr>
  <tr>
    <td><a href="#depth-first-search">DepthFirstSearch</a><br />(prohledávání&nbsp;do&nbsp;hloubky)</td>
    <td>Grafové prohledávání, kde nově expandované elementy jsou dány na začátek fronty. Vyžaduje méně paměti než
    prohledávání do šířky, ale nezaručuje nejkratší cestu k řešení.</td>
    <td>Grafové</td>
    <td>{javadoc "problem.StartingConfigurationProblem"}</td>
  </tr>
  <tr>
    <td><a href="#genetic-algorithm">GeneticAlgorithm</a><br />(genetický&nbsp;algoritmus)</td>
    <td>Vytváří populaci řešení z předchozí populace pomocí opakované reprodukce dvou konfigurací.</td>
    <td>Globální</td>
    <td>{javadoc "problem.RandomConfigurationProblem"}<br />
    {javadoc "problem.GlobalSearchProblem"}
    </td>
  </tr>
  <tr>
    <td><a href="#graph-search-algorithm">GraphSearch</a><br />(grafové&nbsp;prohledávání)</td>
    <td>Abstraktní předek všech grafových algoritmů. Vyžaduje implementaci fronty, kterou bude využívat na ukládání
    expandovaných elementů.</td>
    <td>Grafové</td>
    <td>{javadoc "problem.StartingConfigurationProblem"}</td>
  </tr>
  <tr>
    <td><a href="#simulated-annealing">SimulatedAnnealing</a><br />(simulované&nbsp;žíhání)</td>
    <td>Lokálně prohledává prostor (vybírá náhodnou operaci) a s klesající pravděpodobností přijímá i zhoršující 
    řešení.</td>
    <td>Lokální</td>
    <td>{javadoc "problem.RandomConfigurationProblem"}<br />
    nebo {javadoc "problem.StartingConfigurationProblem"}
    </td>
  </tr>
</table>

<p class="fig-title">Table 1: Seznam všech algoritmů v JCOPu.</p>

<h3 id="breadth-first-search">BreadthFirstSearch</h3>

<p>
  {javadoc "algorithm.graphsearch.bfs.BreadthFirstSearch"} (prohledávání do šířky) prochází všechny možné konfigurace.
  Dříve expandované konfigurace jsou zpracovány jako první. Je velmi pomalý a paměťově náročný, ale vždy najde optimální
  řešení a nejkratší cestu k němu. 
</p>

{include "../fig.phtml", "url" => "bfs-animated.gif", "url_thumb" => "bfs-animated_resize.gif", "title" => "Animovaný BFS, zdroj: <a href=\"http://commons.wikimedia.org/wiki/File:Breadth-First-Search-Algorithm.gif\">commons.wikimedia.org</a>", "fig" => "1"}

<h3 id="depth-first-search">DepthFirstSearch</h3>

<p>
  {javadoc "algorithm.graphsearch.dfs.DepthFirstSearch"} (prohledávání do hloubky) prochází všechny možné konfigurace.
  Poslední expandované konfigurace jsou zpracovány jako poslední. Je velmi pomalý, ale zaručuje nalezení nejlepší
  konfigurace (ačkoli ne nejkratší cesty k ní).
</p>

{include "../fig.phtml", "url" => "dfs-animated.gif", "url_thumb" => "dfs-animated_resize.gif", "title" => "Animovaný DFS, zdroj: <a href=\"http://commons.wikimedia.org/wiki/File:Depth-First-Search.gif\">commons.wikimedia.org</a>", "fig" => "2"}

<h3 id="genetic-algorithm">GeneticAlgorithm</h3>

<p>
  {javadoc "algorithm.geneticalgorithm.GeneticAlgorithm"} (genetický algoritmus) simuluje evoluci v přírodě. Nejprve
  vytvoří populaci náhodných konfigurací a poté opakovaně vybere dva jedince (vyšší fitness má vyšší šanci na výběr)
  a vytvoří z nich potomky do nové populace. Každý optimalizační krok se skládá z vytvoření celé nové populace. Běžné
  nastavení pro tento algoritmus je velikost populace a míra mutace. Doporučená vylepšení jsou implementace rozhraní
  {javadoc "algorithm.geneticalgorithm.Selection"}, {javadoc "algorithm.geneticalgorithm.Mutation"} a {javadoc "algorithm.geneticalgorithm.Reproduction"}.
</p>
<h3 id="graph-search-algorithm">GraphSearch</h3>

<p>
  {javadoc "algorithm.graphsearch.GraphSearch"} (grafové prohledávání) je abstraktní základ pro algoritmy jako jsou
  BFS nebo DFS. Tyto obvykle fungují téměř stejně a jediný rozdíl je to, jakým způsobem uchovávají jejich otevřené
  (a zavřené) stavy (konfigurace). Jeden optimalizační krok znamená vzít jednu otevřenou konfiguraci, expandovat ji do
  všech okolních stavů a tyto dát do otevřené fronty (nemusí se jednat o <a href="http://en.wikipedia.org/wiki/First_in,_first_out">FIFO
  frontu</a>, může to být libovolná datová struktura).
</p>

<p>
  Interakce s touto frontou je definována pomocí rozhraní {javadoc "algorithm.graphsearch.GraphSearchQueue"}. Tři
  nejdůležitější metody jsou {javadoc "algorithm.graphsearch.GraphSearchQueue#fetch()"}, která vrací jeden otevřený stav
  na expanzi, {javadoc "algorithm.graphsearch.GraphSearchQueue#add(cz.cvut.felk.cig.jcop.problem.Configuration)"} pro
  přidání nového stavu do fronty a {javadoc "algorithm.graphsearch.GraphSearchQueue#testPresence(cz.cvut.felk.cig.jcop.problem.Configuration)"}
  na otestování, jestli je daná konfigurace buď v seznamu otevřených nebo zavřených stavů. Implementací těchto metod lze
  ovlivnit, jestli algoritmus bude prohledávat do šířky, hloubky nebo například používat nějakou heuristickou metodiku.
</p>

<h3 id="simulated-annealing">SimulatedAnnealing</h3>

<p>
  {javadoc "algorithm.simulatedannealing.SimulatedAnnealing"} (simulované žíhání) pracuje pouze s jednou konfigurací. V
  každém optimalizačním kroku se pokusí aplikovat náhodně vybranou operaci na tuto konfiguraci. Pokud je nové řešení
  lepší nebo splní test teploty, je přijato. Jinak se aktuální konfigurace nemění.
</p>

<p>
  Simulované žíhání má počáteční teplotu, která se v každém optimalizačním kroku snižuje o určitý koeficient (obě
  hodnoty lze nastavit). Vyšší teplota znamená větší šanci přijmout horší konfiguraci (a to, jak moc je horší je tato
  konfigurace také ovlivňuje pravděpodobnost přijetí).
</p>

<p>
  Aby mohlo simulované žíhání pracovat správně, potřebuje aby všechny problémy byly schopny dávat jejich fitness v
  rozsahu od 0.0 do 1.0 (včetně). Tento předpoklad je již obsažen v rozhraní {javadoc "problem.BaseFitness"}.
</p>