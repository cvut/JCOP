{block #title}Problems{/block}
{block #chapter}C.{/block}
{block #content}

<h3>List of all problems in JCOP</h3>

<p>
  In <a href="#table-1">table 1</a> is a list of all problems bundled with JCOP, along with brief description and
  provided interfaces.
</p>

<table class="full" id="table-1">
  <tr>
    <th>Name</th>
    <th>Description</th>
    <th>Provided interfaces</th>
  </tr>
  <tr>
    <td><a href="#bucket">Bucket</a></td>
    <td>Buckets of given capacity and starting contents are required each to have given contents in every bucket by using operations
    fill, spill and pour one bucket into another.</td>
    <td>
      {javadoc "problem.Problem"}<br />
      {javadoc "problem.DestinationProblem"}<br />
      {javadoc "problem.StartingConfigurationProblem"}
    </td>
  </tr>
  <tr>
    <td><a href="#job-shop">JobShop</a></td>
    <td>Plan <code>n</code> different jobs, each given duration, on <code>m</code> (<code>m</code> &lt; <code>n</code>)
    identical machines, each able to run one job at
    a time. Find assignment of jobs to machines with minimal total duration.</td>
    <td>
      {javadoc "problem.Problem"}<br />
      {javadoc "problem.StartingConfigurationProblem"}<br />
      {javadoc "problem.RandomConfigurationProblem"}<br />
      {javadoc "problem.GlobalSearchProblem"}
    </td>
  </tr>
  <tr>
    <td><a href="#knapsack">Knapsack</a></td>
    <td>Add items with given capacity and price to a knapsack, which can hold only given weight. Maximize total price
    of items in knapsack.</td>
    <td>
      {javadoc "problem.Problem"}<br />
      {javadoc "problem.StartingConfigurationProblem"}<br />
      {javadoc "problem.RandomConfigurationProblem"}<br />
      {javadoc "problem.GlobalSearchProblem"}
    </td>
  </tr>
  <tr>
    <td><a href="#sat">SAT</a></td>
    <td>Assign boolean values to variables (each given weight) so that given formula evaluates to true. Minimize weight
    of variables assigned with true.</td>
    <td>
      {javadoc "problem.Problem"}<br />
      {javadoc "problem.StartingConfigurationProblem"}<br />
      {javadoc "problem.RandomConfigurationProblem"}<br />
      {javadoc "problem.GlobalSearchProblem"}
    </td>
  </tr>
  <tr>
    <td><a href="#tsp">TSP</a></td>
    <td>Find in which order to visit a list of cities (each given distance to all others) such that every city is
    visited exactly once and total trip length is minimal.</td>
    <td>
      {javadoc "problem.Problem"}<br />
      {javadoc "problem.StartingConfigurationProblem"}
    </td>
  </tr>
</table>

<h3 id="bucket">Bucket</h3>

<p>
  {javadoc "problem.bucket.Bucket"} starts with a set of  <code>n</code> buckets, each with given capacity and contents.
  The goal is to have each bucket with given contents. Only allowed operations are to fill bucket (to its capacity),
  spill bucket empty or pour one bucket into another (if there is not enough space in destination bucket, rest is left
  in source one). 
</p>

<p>
  Bucket is initialized with arrays of integers as shown below.
</p>

<pre class="brush: java;">
Bucket bucket = new Bucket(new int[]{!="{"}14, 10, 6, 2, 8}, new int[]{!="{"}0, 0, 1, 0, 0}, new int[]{!="{"}12, 6, 4, 1, 8});
</pre>

<p>
  This creates 5 buckets problem, with capacities of 14, 10, 6, 2, 8, starting contents 0, 0, 1, 0, 0 and destination
  contents of 12, 6, 4, 1, 8. Best solution with such parameters is (Pour 2 into 0, Fill 1, Pour 1 into 2, Pour 2 into
  4, Fill 2, Pour 2 into 3, Pour 3 into 1, Pour 0 into 3, Fill 0, Pour 0 into 4), where numbers are indexes of buckets
  (indexed from 0).
</p>

<p>
  Three operations are {javadoc "problem.bucket.FillOperation"} (fills bucket to the brim), {javadoc "problem.bucket.SpillOperation"}
  (empties a bucket) and {javadoc "problem.bucket.PourOperation"} (pours contents of one bucket into another).
  Default fitness {javadoc "problem.bucket.BucketFitness"} ranges from 0 to <code>n</code>, the number equals how many
  buckets have its destination contents. Configuration has <code>n</code> variables, each representing capacity of
  one bucket.
</p>

<h3 id="job-shop">JobShop</h3>

<p>
  {javadoc "problem.jobshop.JobShop"} is problem where you have given <code>n</code> jobs, each having its duration, and
  <code>m</code> identical machines. The goal is to assign every job a machine on which to run it with minimal total
  duration.
</p>

<p>
  JobShop is initialized with a list of integers (jobs duration) and number of machines as shown below.
</p>

<pre class="brush: java;">
List&lt;Integer&gt; jobs = new ArrayList&lt;Integer&gt;(5);
jobs.add(5);
jobs.add(4);
jobs.add(6);
jobs.add(2);
jobs.add(2);
JobShop jobShop = new JobShop(jobs, 3);
</pre>

<p>
  This creates a JobShop with 5 jobs with durations 5, 4, 6, 2 and 2, and 3 machines. Best solutions to have jobs
  1 and 4 on machine 0, jobs 0 and 3 on machine 1 and job 2 on machine 2. Total time is 7.
</p>

<p>
  Only one operation is {javadoc "problem.jobshop.MoveOperation"} which moves job from one machine to another. Default
  fitness {javadoc "problem.jobshop.JobShopFitness"} is calculated such that if all jobs are on single machine, fitness
  is 0. For every saved unit of time fitness is increased by 1. Configuration has <code>n</code> variables, each
  representing number of machine on which job runs.
</p>

<h3 id="knapsack">Knapsack</h3>

<p>
  In {javadoc "problem.knapsack.Knapsack"} there are <code>n</code> items with given price and weight (represented as
  {javadoc "problem.knapsack.KnapsackItem"}) and capacity of knapsack. We need to put items to knapsack so that total
  weight of items is no more than knapsack's capacity and total price is maximal.
</p>

<p>
  Knapsack is initialized either from file or a string. Both takes the same format, in case of file is used either
  first line or line with given id. First number in line is id, second number of items, third is knapsack capacity.
  Then follows pairs weight-price for every item. Below is shown example when loading form string.
</p>

<pre class="brush: java;">
Knapsack knapsack = new Knapsack("9000 4 100 18 114 42 136 88 192 3 223");
</pre>

<p>
  This creates a Knapsack with 4 items (weighting 18, 42, 88 and 3, pricing 114, 136, 192, 223), id 9000 and knapsack
  capacity 100. Best solution is to have items 0, 1 and 3 in knapsack (total weight 63, total price 473). 
</p>

<p>
  Two operations are {javadoc "problem.knapsack.AddOperation"} (adds item to knapsack) and {javadoc "problem.knapsack.RemoveOperation"}
  (removes item from knapsack). Default fitness is {javadoc "problem.knapsack.KnapsackFitness"} and works such that
  overfilled knapsack has negative fitness (higher total price means higher fitness) and positive number if total weight
  is not greater than knapsack's capacity (in that case fitness is total price). Configuration has one variable for every
  item, 0 means item is not present, 1 items is present.
</p>

<h3 id="sat">SAT</h3>

<p>
  {javadoc "problem.sat.SAT"} has <code>n</code> variables (each having a weight) and one formula (product of sums). The
  goal is to assign each variable either true or false so that formula evaluates to true and total weight of all true
  variables is minimal.
</p>

<p>
  SAT is initialized from file (for format see {javadoc "problem.sat.SAT#SAT(java.io.File)"}). It creates <code>n</code>
  variables and <code>m</code> clauses. In every clause, there are any number (but usually 3 as for 3-SAT problem) of
  variables, which can be negated. Below is example how to load from file:
</p>

<pre class="brush: java;">
SAT sat = new SAT(new File("data/sat/easy.cnf"));
</pre>

<p>
  This creates a SAT from file <code>data/sat/easy.cnf</code>. 
</p>

<p>
  Two operations are {javadoc "problem.sat.SetTrueOperation"} (sets variable to true) and {javadoc "problem.sat.SetFalseOperation"}
  (sets variable to false). Default fitness is {javadoc "problem.sat.SATFitness"} and is calculated that if formula is 
  satisfied, fitness is positive number (higher weight means lower fitness). If formula is not satisfied, fitness is
  negative number of non-satisfied clauses. Configuration has <code>n</code> variables, each either 0 (variable is
  false) or 1 (variable is true).
</p>

<h3 id="tsp">TSP</h3>

<p>
  {javadoc "problem.tsp.TSP"} (traveling salesman problem) has <code>n</code> cities and for every city distance to
  every other. Goal is to find a tour in which to visit each city so that every one is visited exactly once and total
  distance is minimal (also known as <a href="http://en.wikipedia.org/wiki/Hamiltonian_cycle">Hamiltonian cycle</a>).
</p>

<p>
  TSP is initialized from 2D array of Integer - square matrix of distances (allowing asymmetric TSP). For every row in
  the matrix, one {javadoc "problem.tsp.City"} is created with map of distances to other cities. Below is example how
  to load TSP from array:
</p>

<pre class="brush: java;">
TSP tsp = new TSP(new Integer[][]{!="{"}
        {!="{"} 0, 20, 42, 35},
        {!="{"}20,  0, 30, 34},
        {!="{"}42, 30,  0, 53},
        {!="{"}35, 34, 53,  0},
});
</pre>

<p>
  This creates TSP with 4 cities. Distance from first to second is 20, from first to third is 42 etc. Best solution is
  to visit cities in order city 2, city 1, city 0 and city 3. Total distance is 97.
</p>

<p>
  One operations is {javadoc "problem.tsp.SwitchCityOperation"} which switches two cities in a tour (eg. when city A was
  to be visited at k-th position and city B at j-th position, after switch is city A visited at j-th position and B at
  i-th). Default fitness is {javadoc "problem.tsp.TSPFitness"}, value is either negative distance (if configuration is
  invalid tour) or positive number - shorter tour means higher fitness. Configuration has <code>n</code> variables,
  indexes are position in tour and values are indexes of cities. For example configuration [2,3,1,0] means that first
  is visited city 2, then city 3, then city 1 and last is city 0.
</p>