{block #title}Problém{/block}
{block #chapter}2.5{/block}
{block #content}

<p>
  Problém definuje jak se jeden konkrétní kombinatorický problém chová. Je několik základních informací, které musí
  poskytovat každý problém, a řada nepovinných, které zaručí, že problém lze řešit větším množstvím algoritmů (nebo
  využít existující algoritmy efektivněji). Které informace bude algoritmus poskytovat je dáno tím, které rozhraní
  poskytuje.
</p>

<p>
  Různá rozhraní budou probrána důkladně později, zde si teď ukážeme jeden problém, který je v JCOPu implementován, jak
  funguje a jak ho upravit.
</p>

<p>
  Podívejme se na {javadoc "problem.knapsack.Knapsack"} problém. Problém batohu (přesněji 0-1 problém batohu) má danou
  množinu věcí (každá s danou hmotností a cenou) a kapacitu batohu. Cílem je vybrat podmnožinu věcí takovou, že jejich
  celková hmotnost nepřekročí kapacitu batohu a zároveň cena je maximální možná. Problém demonstruje <a href="#fig1">obrázek 1</a>
  převzatý z wikimedia.
</p>

{include "../fig.phtml", "url" => "knapsack-wiki.png", "url_thumb" => "knapsack-wiki_resize.png", "title" => "Problém batohu, zdroj: <a href=\"http://en.wikipedia.org/wiki/Knapsack_problem\">wikipedia.org</a>", "fig" => "1"}

<p>
  Jak je ukázáno na <a href="#fig2">obrázku 2</a>, problém batohu se skládá ze šestice tříd. Podívejme se na to, k čemu
  se která používá.
</p>

{include "../fig.phtml", "url" => "knapsack-structure.png", "url_thumb" => "knapsack-structure_resize.png", "title" => "Struktura problému batohu", "fig" => "2"}

<h3>Problém</h3>

<p>
  {javadoc "problem.knapsack.Knapsack"} je jádrem problému - zpracovává především vstup od uživatele a převádí ho na plně
  nakonfigurovaný problém, poskytuje jak náhodné (náhodně zvolené věci jsou v batohu) tak startovní (prázdný batoh)
  konfigurace, výchozí fitness pro tento problém a vytváří operace (resp. OperationIterator, o něm více dále).
</p>

<h3>KnapsackItem</h3>

<p>
  {javadoc "problem.knapsack.KnapsackItem"} není vyžadován přímo JCOPem a je pouze interně využíván {javadoc "problem.knapsack.Knapsack"},
  aby bylo možné sledovat, které věci (jejich hmotnost, cena a index) jsou v daném problému.
</p>

<h3>Fitness</h3>

<p>
  {javadoc "problem.knapsack.KnapsackFitness"} je výchozí fitness, která ohodnotí každou konfiguraci problému tak, že
  nepřetížený batoh má vždy vyšší fitness než přetížený a zároveň konfigurace s vyšší celkovou cenou má vyšší fitness
  než konfigurace s nižší cenou (první jmenované má vyšší prioritu). Toto je velmi důležitá část problému, protože
  obrovská většina algoritmů používá právě default fitness, aby mohly fungovat správně.
</p>

<h3>Operace</h3>

<p>
  {javadoc "problem.knapsack.AddOperation"} a {javadoc "problem.knapsack.RemoveOperation"} jsou dva představitelé
  konceptu, který jsme zatím neviděli. V JCOPu jsou dva typy algoritmů - globální prohledávání a lokální. Globální
  prohledávání probereme později, ale všechny lokální algoritmu fungují na stejném principu. Mají jednu nebo více
  konfigurací ve stavovém prostoru a používají {javadoc "problem.Operation"} pro navigaci v tomto prostoru. Pokud by byl
  stavový prostor reprezentován jako graf, operace by byly jeho orientované hrany.
</p>

<p>
  Operace se aplikují na konfiguraci a vznikne nové konfigurace. Vždy transformují výhradně jednu konfiguraci do jedné nové
  (stará je zachována beze změny). Je však možné jednu operaci aplikovat opakovaně na několik různých konfigurací.
  Podívejme se teď na {javadoc "problem.knapsack.AddOperation"}.
</p>

<p>
  Na platformě JCOP musí operace implementovat rozhraní {javadoc "problem.Operation"}, které vyžaduje pouze jednu metodu
  {javadoc "problem.Operation#execute(cz.cvut.felk.cig.jcop.problem.Configuration)"}. Jako parametr je jedna (vstupní)
  konfigurace, výsledek je nová. Pokud se podíváme na zdrojový kód {javadoc "problem.knapsack.AddOperation"}, vidíme,
  že operace pouze vezme seznam atributů ze vstupní konfigurace, nastaví jednu hodnotu na 1 (přidá věc s daným indexem
  do batohu) a vrátí novou konfiguraci vytvořenou z tohoto seznamu.
</p>

<pre class="brush: java;">
  public Configuration execute(Configuration configuration) {
      List&gt;Integer&lt; newConfiguration = configuration.asList();

      newConfiguration.set(this.knapsackItem.getIndex(), 1);

      return new Configuration(newConfiguration, new OperationHistory(this, configuration.getOperationHistory()));
  }
</pre>

<p>
  Jediná složitější část je druhý parametr konstruktoru konfigurace - {javadoc "result.OperationHistory"}. Zatím si s ní
  nelamte hlavu, bude vysvětlena později. Pouze rychlý popis - některé problémy potřebují nejen výsledek, ale i cestu k
  němu (např. problém přelévání kýblů), takže je třeba si udržovat historii všech operací aplikovaných na konfiguraci.
</p>

<h3>OperationIterator</h3>

<p>
  Obecně vzato, pro každou konfiguraci ve stavovém prostoru existuje seznam validních operací, který je podmnožinou všech
  operací problému. V problému batohu, konfigurace s prázdným batohem nebude mít žádné {javadoc "problem.knapsack.RemoveOperation"},
  ale bude mít operaci {javadoc "problem.knapsack.AddOperation"} pro každou věc v problému. Pokud by však problém vracel
  seznam všech operací pro každou konfiguraci, JCOP by mohl mít velmi vysoké paměťové nároky pro některé algoritmy. Aby
  se vyrovnal s tímto nedostatkem, problém vrací {javadoc "problem.OperationIterator"}, který se chová jako normální
  iterátor na <a href="http://java.sun.com/javase/6/docs/api/java/util/List.html">List</a> operací, ale samotné
  operace vytváří až za běhu, když jsou potřeba.
</p>

<p>
  Pokud se podíváme na {javadoc "problem.knapsack.KnapsackIterator"} část po části, uvidíme, že je vytvořen jen s referencí
  na problém a konfiguraci, takže sám nespotřebovává prakticky žádnou paměť.
</p>

<pre class="brush: java;">
public class KnapsackIterator implements OperationIterator {
    protected int counter = 0;
    protected Configuration configuration;
    protected Knapsack problem;

    public KnapsackIterator(Configuration configuration, Knapsack problem) {
        this.configuration = configuration;
        this.problem = problem;
        this.counter = 0;
    }
    /** ... */
}
</pre>

<p>
  Atribut counter se zde používá pro to, abychom věděli, kterou operaci jsme naposled vrátili. Když je od iterátoru
  požadována další operace (stejně jako bychom ji chtěli v normální iterátoru), {javadoc "problem.knapsack.KnapsackIterator"}
  zkonstroluje, jestli ještě nějaká operace zbývá. Pokud ano, tak vrátí buď {javadoc "problem.knapsack.AddOperation"}
  nebo {javadoc "problem.knapsack.RemoveOperation"}, podle toho, jestli konfigurace má 1 nebo 0 na indexu rovnému
  <code>this.counter</code>. Problém batohu uchovává všechny možné operace ve dvou seznamech ({javadoc "problem.knapsack.Knapsack#removeOperations"}
  a {javadoc "problem.knapsack.Knapsack#removeOperations"}), takže pouze potřebujeme vzít danou operaci z jednoho z těchto
  listů a tu vrátit.
</p>

<pre class="brush: java;">
  public Operation next() throws NoSuchElementException {
      if (this.counter &gt;= this.problem.knapsackItems.size())
          throw new NoSuchElementException("Knapsack iterator has no more operations");

      if (this.configuration.valueAt(this.counter) == 1)
          return this.problem.removeOperations.get(this.counter++);
      return this.problem.addOperations.get(this.counter++);
  }
</pre>

<p>
  Jediná věc, co zbývá implementovat, jsou {javadoc "problem.OperationIterator#hasNext()"} a
  {javadoc "problem.OperationIterator#getRandomOperation()"}, ale obě jsou velmi jednoduché na implementaci:
</p>

<pre class="brush: java;">
public boolean hasNext() {
    return this.counter &lt; this.problem.knapsackItems.size();
}
public Operation getRandomOperation() throws UnsupportedOperationException {
    int i = JcopRandom.nextInt(this.problem.knapsackItems.size());
    if (this.configuration.valueAt(i) == 1)
        return this.problem.removeOperations.get(i);
    return this.problem.addOperations.get(i);
}
</pre>

<h3>Úpravy</h3>

<p>
  Když chcete změnit existující problém, obvykle měníte buď jak se problém načítá, jak se počítá fitness nebo jaké operace
  (popř. v jakém pořadí) problém poskytuje. 
</p>

<p>
  První změna je velmi jednoduchá - prostě pouze přidejte nový konstruktor,který načte data požadovaným způsobem. Pokud
  chcete změnit fitness, je nutné si uvědomit, že smíte měnit pouze default fitness (výchozí fitness) - nezávisle na tom,
  co provede problém, algoritmus nebo solver musejí být tuto věc přepsat. Pro měnu používané fitness je tedy třeba
  přepsat metodu {javadoc "problem.Problem#getDefaultFitness()"}:
</p>

<pre class="brush: java;">
public Fitness getDefaultFitness() {
    return new KnapsackFitness(this);
}
</pre>

<p>
  tak, aby vracela vaší třídu. Je důležité zmínit, že vytvoření vlastní třídy na výpočet fitness není zcela primitivní,
  pokud má fitness fungovat bez problémů, a bude jí věnován prostor v příštích kapitolách. Pokud se nemůžete dočkat,
  můžete se zkusit inspirovat ve fitness třídách již implementovaných v JCOPu.
</p>

<p>
  Úprava {javadoc "problem.OperationIterator"} je opět velmi jednoduchá - pouze přepište metodu která vrací další
  operaci ({javadoc "problem.OperationIterator#next()"}) a to je vše!
</p>

<h3>ObjectiveProblem</h3>

<p>
  V předchozích kapitolách bylo zmíněno, že v solveru (a algoritmu jak uvidíme dále) se používá {javadoc "problem.ObjectiveProblem"}
  místo normálního {javadoc "problem.Problem"}. Tato technika se v JCOPu používá z důvodu, že jeden problém může splňovat
  (a obvykle splňuje) velké nmožství různých interfaců, uživatel by byl nucen psát kódy v algoritmu (nebo solveru),
  které jsou podobné následujícímu:
</p>

<pre class="brush: java;">
public void myMethod(Problem problem) {
    if (!problem instanceOf StartingConfigurationProblem) throw new Exception("required StartingConfigurationProblem problem");
    if (!problem instanceOf DestinationProblem) throw new Exception("required DestinationProblem problem");

    Configuration startingConfiguration = ((StartingConfigurationProblem)problem)->getStartingConfiguration();
    Configuration DestinationProblem = ((DestinationProblem)problem)->getDestination();
    /** ... */
}
</pre>

<p>
  Což znamená spoustu přetypovávání a instanceOf podmínek, které znepřehledňují kód a dělají ho složitější na údržbu.
  JCOP přichází s jiným řešení - interface {javadoc "problem.ObjectiveProblem"} a jeho výchozí implementace
  {javadoc "problem.BaseObjectiveProblem"}. Tato třída je jakýmsi wrapperem okolo problému, ale implementuje všechna
  rozhraní problému. Když vytvoříte instanci {javadoc "problem.BaseObjectiveProblem"}, předáte {javadoc "problem.Problem"}
  jako parametr v konstruktoru. Všechna volání metod na tento baseObjectiveProblem jsou poté přesměrována na původní
  problem (správně přetypovaný) nebo vyvolají výjimku, pokud problém neimplementoval dané rozhraní. Díky tomuto můžete
  pracovat s {javadoc "problem.ObjectiveProblem"} namísto normálního a nemusíte si dělat startosti s typováním a
  instanceOf podmínkami.
</p>

<p>
  Úplný seznam problémů připravených v JCOPu je uveden v <a href="{link Appendix:problems}">Příloze C</a>.
</p>