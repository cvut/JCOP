{block #title}Result (Výsledek){/block}
{block #chapter}2.4{/block}
{block #content}

<p>
  V naší předchozí ukázce jsme vytvořili solvera, který bude schopen úspěšně aplikovat algoritmus na problém, ale zatím
  jsme nedostali žádné informace o výsledku. K tomuto účelu se využívá výsledek - Result.
</p>

<p>
  Kvůli tomu, že solver je schopen používat více algoritmů nebo řešit více problémů v jednom běhu {javadoc "solver.Solver#run()"},
  jeden solver musí být schopen udržovat několik různých dílčích výsledků. Tohoto je dosaženo rozhraním {javadoc "result.Result"}
  a jeho nejjednodušší implementací {javadoc "result.SimpleResult"}, která pouze výsledky ukládá do Listu.
</p>

<p>
  Stejně jako {javadoc "result.Result"} udržuje informace o celém běhu {javadoc "solver.Solver#run()"}, {javadoc "result.ResultEntry"}
  (záznam výsledku) nás informuje o jedné dílčí iteraci solveru. Objekt této třídy obsahuje všechna podstatná data ohledně toho, jak aplikace
  algoritmu skončila (např. počet iterací, čas běhu nebo nejlepší řešení). Vytvoření result entry je snadné - pouze
  vytvoříme objekt jedním z jeho konstruktorů. Zde použijeme {javadoc "result.ResultEntry#ResultEntry(cz.cvut.felk.cig.jcop.algorithm.Algorithm, cz.cvut.felk.cig.jcop.problem.Problem, cz.cvut.felk.cig.jcop.problem.Configuration, double, int, cz.cvut.felk.cig.jcop.util.PreciseTimestamp)", "ResultEntry#ResultEntry(...)"}.
  Zde je jedna věc, kterou jsme zatím neviděli - {javadoc "util.PreciseTimestamp"}. Tato třída je používána k měření
  přesnějšího času než je obyčejný reálný čas. Víc bude probrána v dalších kapitolách, nyní z ní pouze vytvoříme instanci
  těsně před spuštění algoritmu a předáme ji do result entry jako startTime.
</p>

<p>
  Z parametrů, které result entry požaduje, máme algoritmus a problém, které na sebe aplikujeme, a {javadoc "util.PreciseTimestamp"}.
  Dále potřebujeme nejlepší nalezenou {javadoc "problem.Configuration"}, nejlepší fitness a počet optimalizací (optimization counter).
  První dvě vezmeme přímo z algoritmu - algoritmus je musí poskytovat implementací interfacu {javadoc "algorithm.Algorithm"}
  (konkrétně metody {javadoc "algorithm.Algorithm#getBestConfiguration()"} a {javadoc "algorithm.Algorithm#getBestFitness()"}).
  Poslední, počet optimalizací, musí dodat solver. Tím, že víme, že jsme provedli 10 kroků, tak můžeme dodat přímo číslo 10.
</p>

<pre class="brush: java;">
package basicusage.result;

import cz.cvut.felk.cig.jcop.algorithm.Algorithm;
import cz.cvut.felk.cig.jcop.problem.BaseObjectiveProblem;
import cz.cvut.felk.cig.jcop.problem.Problem;
import cz.cvut.felk.cig.jcop.result.Result;
import cz.cvut.felk.cig.jcop.result.ResultEntry;
import cz.cvut.felk.cig.jcop.result.SimpleResult;
import cz.cvut.felk.cig.jcop.solver.BaseSolver;
import cz.cvut.felk.cig.jcop.solver.Solver;
import cz.cvut.felk.cig.jcop.util.PreciseTimestamp;

public class PrimitiveSolver extends BaseSolver implements Solver {
    protected Problem problem;
    protected Algorithm algorithm;
    protected Result result = new SimpleResult();

    public PrimitiveSolver(Algorithm algorithm, Problem problem) {
        this.algorithm = algorithm;
        this.problem = problem;
    }

    public void run() {
        // init algorithm
        this.algorithm.init(new BaseObjectiveProblem(this.problem));

        // take starting time
        PreciseTimestamp startTimestamp = new PreciseTimestamp();

        // make 10 optimizations
        for (int i = 0; i &lt; 10; i++) this.algorithm.optimize();

        // create result entry
        ResultEntry resultEntry = new ResultEntry(this.algorithm, this.problem, this.algorithm.getBestConfiguration(), this.algorithm.getBestFitness(), 10, startTimestamp);
    }
}
</pre>

<p>
  Teď, když máme result entry pro iteraci našeho 10-krokého solveru, musíme ho přidat do resultu. Z {javadoc "solver.Solver"}
  interfacu solver musí implementovat {javadoc "solver.Solver#getResult()"} metodu. Naštěstí protože dědíme z {javadoc "solver.BaseSolver"},
  {javadoc "result.Result"} je pro nás automaticky vytvořen a nám stačí do něj pouze přidat nový záznam.
</p>

<pre class="brush: java;">
package basicusage.result;

import /** ... */

public class PrimitiveSolver extends BaseSolver implements Solver {
    /** ... */
    public void run() {
        /** ... */
        // add it to result
        this.getResult().addEntry(resultEntry);
    }
}
</pre>

<p>
  Teď když máme výsledky z běhu solveru, potřebujeme je nějak zobrazit (lépe nazýváno vyrenderovat). Třídy, které
  implementují rozhraní {javadoc "result.render.Render"}, se používají k renderování výsledků různýmy způsoby (např.
  XML soubor, text do konzole atd). Existuje několik renderů předpřipraveným v JCOPu a my budeme používat {javadoc "result.render.SimpleRender"},
  který pouze vypíše textový výsledek do konzole. Render se do solveru zaregistruje (přidá) pomocí {javadoc "solver.Solver#addRender(cz.cvut.felk.cig.jcop.result.render.Render)"}.
  Toto je většinou děláno mimo solver, protože solver sám o sobě nemusí vědět, jak my chceme renderovat data, ví pouze
  jak aplikovat algoritmy na problémy, ne jak zobrazit výsledek. Upravme tedy náš DemoPrimitiveSolver z
  minulé kapitoly:
</p>

<pre class="brush: java;">
package basicusage.result;

import cz.cvut.felk.cig.jcop.algorithm.Algorithm;
import cz.cvut.felk.cig.jcop.algorithm.graphsearch.bfs.BreadthFirstSearch;
import cz.cvut.felk.cig.jcop.problem.Problem;
import cz.cvut.felk.cig.jcop.problem.knapsack.Knapsack;
import cz.cvut.felk.cig.jcop.result.render.SimpleRender;
import cz.cvut.felk.cig.jcop.solver.Solver;

public class DemoPrimitiveSolver {
    public static void main(String[] args) {
        // create problem &amp; algorithm
        Problem problem = new Knapsack("9000 4 100 18 114 42 136 88 192 3 223");
        Algorithm algorithm = new BreadthFirstSearch();

        // create solver
        Solver solver = new PrimitiveSolver(algorithm, problem);

        // add simple render
        solver.addRender(new SimpleRender());

        // run!
        solver.run();

        // render results
        solver.render();
    }
}
</pre>

<p>
  Přidali jsme {javadoc "result.render.SimpleRender"} do našeho solveru a jakmile metoda {javadoc "solver.Solver#run()"}
  skončí, zavolali jsme {javadoc "solver.Solver#render()"}, což způsobí, že všechny zaregistrované rendery se vykreslí.
  Měli byste mít v konzoli něco podobného následujícímu, pokud ne, nejspíše jste něco udělali špatně:
</p>

<pre class="brush: plain;">
=== Algorithm BreadthFirstSearch [] used on problem Knapsack [line=9000 4 100 18 114 42 136 88 192 3 223] ===
  CPU Time:                       1 [ms]
  System Time:                    1 [ms]
  User Time:                      1 [ms]
  Clock Time:                    16 [ms]
  Optimize counter:              10 [-]
  Optimize/sec (CPU):         10000 [1/s]
  Optimize/sec (Clock):         625 [1/s]
  Best solution:         Configuration{!="{"}attributes=[0, 1, 0, 1], operationHistory={!="{"}0:Empty knapsack created, 1:AddOperation{!="{"}knapsackItem=KnapsackItem{!="{"}index=1, weight=42, price=136}}, 2:AddOperation{!="{"}knapsackItem=KnapsackItem{!="{"}index=3, weight=3, price=223}}}}
  Depth:                          2 [-]
  Fitness:                    359,0 [-]
  Ended without exception
</pre>

<p>
  Díky tomu, že jsme použili {javadoc "solver.BaseSolver"} jako předka pro našeho solvera, nemusíme dokonce ani přidávat
  {javadoc "result.render.SimpleRender"}, je nastaven jako výchozí (pokud není zadán žádný jiný). Kód pak může být ještě
  kratší. Dále je třeba poznamenat, že v JCOP existuje {javadoc "solver.SimpleSolver"}, který funguje velmi podobně jako
  nás PrimitiveSolver, ačkoli je o trochu sofistikovanější. Tím, že z velké části ale funguje jako demonstrovaný solver,
  v dalších tutoriálech ho budeme používat.
</p>

<p>
  Obě třídy je možné stáhnout (<a href="{$basePath}/media/tutorial/basicusage.result.zip">zip</a>,
  <a href="{$basePath}/media/tutorial/basicusage.result.tgz">tgz</a>,
  <a href="{$basePath}/media/tutorial/basicusage.result.7z">7z</a>).
</p>

<p>
  Kompletní seznam renderů a listenerů může být nalezen v <a href="{link Appendix:rendersListeners}">Příloze A</a>.
</p>