{block #title}Úvod{/block}
{block #chapter}2.1{/block}
{block #content}

<p>
  Tato část ukazuje základní použití JCOPu, jak fungují jeho hlavní komponenty a&nbsp;jak je správně využít. Předvede, jak
  otestovat, jestli jste nainstalovali JCOP správně a&nbsp;naučí vás, jak nechat solvery, problémy, algoritmy a&nbsp;render pracovat
  pohromadě. Je rozdělena na šest částí, po jejichž přečtení byste měli být schopni JCOP samostatně používat.
</p>

<p>
  Na obrázku <a href="#fig1">figure 1</a> je vidět, jak solver, result, problém a&nbsp;algoritmus společně interagují. Je 
  však důležité si uvědomit, že velká část komunikace (povětšinou mezi solverem a&nbsp;algoritmem) je není pevně stanovená,
  jak je implementovaná, tudíž tento diagram by vypadal jinak pro každou kombinaci solvera a&nbsp;algoritmu. To, co je zde
  ukázáno, je pouze jakási základní myšlenka (velmi blízká chování {javadoc "solver.SimpleSolver"}).
</p>
{include "../fig.phtml", "url" => "sd-algorithm-problem-solver-render.png", "url_thumb" => "sd-algorithm-problem-solver-render_resize.png", "title" => "Sekvenční diagram základní algoritmus-problém-solver-result interakce", "fig" => "1"}
<p>
  Základní scénář je takový, že uživatel (programátor) vytvoří instanci problému a&nbsp;algoritmu. Toto je také okamžik, kdy
  je algoritmus nakonfigurován (např. startovní teplota a&nbsp;koeficient ochlazování pro simulované žíhání) a&nbsp;problém je 
  načten (ze souboru, stringu, datové struktury). Jakmile jsou připraveny, jsou předány solveru (buď jako argumenty v&nbsp;konstruktoru, jak je ukázáno na obrázku, nebo pomocí metod). Nakonec uživatel může přidat další Rendery (vykreslovače)
  nebo Listenery (které ale zatím neřešte, dojde na ně řada později). Tímto končí přípravná fáze.
</p>
<p>
  Následuje hlavní fáze - zde jsou algoritmy použity na řešení problémů a&nbsp;jsou sbírané statistické informace o&nbsp;jejich
  průběhu. Jakmile uživatel zavolá {javadoc "solver.Solver#run()"}, sovler restartuje algoritmus a&nbsp;začne ho aplikovat
  na problém(y). Co tyto dvě části obsahují záleží na použitém algoritmu, ale restart si obvykle vezme alespoň
  počáteční konfiguraci {javadoc "problem.StartingConfigurationProblem#getStartingConfiguration()"} (algoritmy typu BFS/DFS)
  nebo náhodou konfiguraci {javadoc "problem.RandomConfigurationProblem#getRandomConfiguration()"} (genetický algoritmus
  nebo simulované žíhání). Poté solver opakovaně volá metodu {javadoc "algorithm.Algorithm#optimize()"}, která vykoná
  jeden optimalizační krok. V&nbsp;tomto kroku algoritmus může např. vzít operace pomocí {javadoc "problem.Problem#getOperationIterator(cz.cvut.felk.cig.jcop.problem.Configuration)"}
  a&nbsp;expandovat aktivní konfiguraci. Jakmile solver rozhodne, že je třeba ukončit iteraci solveru, vytvoří zprávu o&nbsp;svém
  běhu (nazývanou {javadoc "result.ResultEntry"}) a&nbsp;přidá ji do {javadoc "result.Result"}.
</p>
<p>
  Když už nejsou žádné další iterace solveru (žádné algoritmy, které mají být použity na problémy), začíná poslední fáze.
  Zde uživatel obvykle pouze řekne solveru, aby vyrenderoval všechny své výsledky pomocí zaregistrovaných renderů. Toho
  je dosaženo voláním {javadoc "solver.Solver#render()"}. Až jsou výsledky vypsány (do souborů, konzole atd), životní 
  cyklus JCOPu končí.
</p>

