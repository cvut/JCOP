{block #title}Solver{/block}
{block #chapter}2.3{/block}
{block #content}

<p>
  Jak již bylo zmíněno, solver je něco jako plánovač. Rozhoduje kdy použít který algoritmus, jak dlouho ho používat a
  na jaké probémy. Dále se stará o sběr výsledků a jejich zobrazení. Solver je definován interfacem {javadoc "solver.Solver"}.
  Většina metod má výchozí implementaci ve třídě {javadoc "solver.BaseSolver"}, takže zbývá pouze jedna k implementování
  - {javadoc "solver.Solver#run()"}.
</p>

<p>
  V této metodě, zvané cyklus solveru, jsou algoritmy aplikovány na problémy. Nejjednodušší věc je udělat solvera, který
  vezme jeden algoritmus a jeden problém jako algoritmy:
</p>

<pre class="brush: java;" id="code-primitive-solver-1">
package basicusage.solver;

import cz.cvut.felk.cig.jcop.algorithm.Algorithm;
import cz.cvut.felk.cig.jcop.problem.Problem;
import cz.cvut.felk.cig.jcop.solver.BaseSolver;
import cz.cvut.felk.cig.jcop.solver.Solver;

public class PrimitiveSolver extends BaseSolver implements Solver {
    /**
     * Problem to be solved
     */
    protected Problem problem;
    /**
     * Algorithm to be used
     */
    protected Algorithm algorithm;

    public PrimitiveSolver(Algorithm algorithm, Problem problem) {
        this.algorithm = algorithm;
        this.problem = problem;
    }
}
</pre>

<p>
  Teď však dostaneme chybu - neimplementovali jsme zatím {javadoc "solver.Solver"} interface. Jdeme na to. První věc co
  jsme povinni v {javadoc "solver.Solver#run()"} udělat je zavolat {javadoc "algorithm.Algorithm#init(cz.cvut.felk.cig.jcop.problem.ObjectiveProblem)"}.
  Tím inicializujeme (a restartujeme) algoritmus na problému. Zatím neřešte, proč používáme {javadoc "problem.ObjectiveProblem"}
  jako argument nebo co přesně dělá, vše bude vysvětleno později. Pouze považujte algoritmus za připravený. Teď potřebujeme
  nechat algoritmus "pracovat" na problémy. Toho je dosaženo opakovaným prováděním optimizačního kroku voláním metody
  {javadoc "algorithm.Algorithm#optimize()"}. Nechme našeho solvera udělat 10 optimizačních kroků a poté skončit:
</p>

<pre class="brush: java;" id="code-primitive-solver-2">
package basicusage.solver;

import /** ... */
import cz.cvut.felk.cig.jcop.problem.BaseObjectiveProblem;

public class PrimitiveSolver extends BaseSolver implements Solver {
    /** ... */
    public void run() {
        this.algorithm.init(new BaseObjectiveProblem(this.problem));

        for (int i = 0; i &lt; 10; i++) this.algorithm.optimize();
    }
}
</pre>

<p>
  A to je vše! Pokud chcete tento solver spustit, pouze vytvořte jeho instanci a zavolejte jeho metodu {javadoc "solver.Solver#run()"}.
  Protože zatím nevíte mnoho o algoritmech a problémech, vezměte následující kód a spusťte metodu main. Zatím neuvidíte
  žádné výsledky - ty budou vysvětleny v další kapitole. 
</p>

<pre class="brush: java;" id="code-demo-primitive-solver-1">
package basicusage.solver;

import cz.cvut.felk.cig.jcop.algorithm.Algorithm;
import cz.cvut.felk.cig.jcop.algorithm.graphsearch.bfs.BreadthFirstSearch;
import cz.cvut.felk.cig.jcop.problem.Problem;
import cz.cvut.felk.cig.jcop.problem.knapsack.Knapsack;
import cz.cvut.felk.cig.jcop.solver.Solver;

public class DemoPrimitiveSolver {
    public static void main(String[] args) {
        // create problem &amp; algorithm
        Problem problem = new Knapsack("9000 4 100 18 114 42 136 88 192 3 223");
        Algorithm algorithm = new BreadthFirstSearch();

        // create solver
        Solver solver = new PrimitiveSolver(algorithm, problem);

        // run!
        solver.run();
    }
}

</pre>

<p>
  Pokud běh skončí bez výjimky, tak se vám podařilo udělat váš první solver! Pokud je zde chyba, vraťte se zpět tímto
  tutoriálem a pokuste se najít, co jste udělali jinak. Obě třídy jsou ke stažení zde  
  (<a href="{$basePath}/media/tutorial/basicusage.solver.zip">zip</a>, <a href="{$basePath}/media/tutorial/basicusage.solver.tgz">tgz</a>, 
  <a href="{$basePath}/media/tutorial/basicusage.solver.7z">7z</a>).
</p>

<h3>Implementované solvery</h3>

<p>
  V JCOPu je několik solverů již implementovaných a jejich používání je doporučené místo psaní vlastních.  {javadoc
  "solver.SimpleSolver"} se používá, pokud chcete spustit jeden algoritmus na jednom problému, většinou ve vývojové
   fázi. {javadoc "solver.AlgorithmCompareSolver"} je vhodný na porovnávání výkonu více algoritmů na jednom problému.
   Pro celý seznam jděte na <a href="{link Appendix:solvers}">Appendix A</a>.
</p>

<h3>Ukončovací podmínky (StopConditions)</h3>

<p>
  Důležitou částí solveru jsou ukončovací podmínky ({javadoc "solver.condition.StopCondition", "StopConditions"}). Ty
  jsme v našem jednoduchém solveru neřešili, abychom věci příliš nekomplikovali. Při reálném použití ale potřebujeme
  kontrolovat, kdy přestaneme provádět další iterace solveru. Abychom tohoto mohli dosáhnout, používáme ukončovací
  podmínky.
</p>

<p>
  Každý solver může mít zaregistrovaných libovolné množství ukončovacích podmínek a jakmile je alespoň jedna splněna,
  daná iterace solveru je ukončena. Ukončovací podmínky jsou do solvera přidány voláním {javadoc "solver.Solver#addStopCondition(cz.cvut.felk.cig.jcop.solver.condition.StopCondition)"}.
  Podmínky fungují jako listenery (a jsou automaticky zaregistrováni jako listenery) pro daný solver a ten jim posílá
  zprávy o svém postupu. Po každém optimizačním kroku solver vyhodnotí všechny podmínky a případně se ukončí.
</p>

<p>
  V JCOPu je implementováno několik různých ukončovacích podmínek. Pro jejich použití jděte na <a href="{link Appendix:stopConditions}">Appendix D</a>.
  Použití je velmi jednoduché:
</p>

<pre class="brush: java;">
package basicusage.solver;

import cz.cvut.felk.cig.jcop.algorithm.Algorithm;
import cz.cvut.felk.cig.jcop.algorithm.graphsearch.bfs.BreadthFirstSearch;
import cz.cvut.felk.cig.jcop.problem.Problem;
import cz.cvut.felk.cig.jcop.problem.knapsack.Knapsack;
import cz.cvut.felk.cig.jcop.solver.SimpleSolver;
import cz.cvut.felk.cig.jcop.solver.Solver;
import cz.cvut.felk.cig.jcop.solver.condition.IterationCondition;
import cz.cvut.felk.cig.jcop.solver.condition.TimeoutCondition;

public class DemoCondition {
    public static void main(String[] args) {
        // create problem &amp; algorithm
        Problem problem = new Knapsack("9000 4 100 18 114 42 136 88 192 3 223");
        Algorithm algorithm = new BreadthFirstSearch();

        // create solver
        Solver solver = new SimpleSolver(algorithm, problem);

        // max 10 optimizations
        solver.addStopCondition(new IterationCondition(10));
        // and max 10ms of solver iteration run
        solver.addStopCondition(new TimeoutCondition(10));

        // run!
        solver.run();
    }
}
</pre>

<p>
  Nyní se solver (pozor - již používáme {javadoc "solver.SimpleSolver"}) pokusí udělat maximálně 10 optimizací a zároveň
  nepoběží déle než 10ms (CPU času, viz <a href="{link util}">util</a>).
</p>