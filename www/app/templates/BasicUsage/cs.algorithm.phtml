{block #title}Algoritmus{/block}
{block #chapter}2.6{/block}
{block #content}

<p>
  Nyní když víme jak fungují solvery a&nbsp;problémy, nastal čas ukázat jak napsat vlastní algoritmus, který bude tyto problémy
  řešit. Nebudeme zde tvořit velmi efektivní algoritmus, pouze jednoduchou ukázku která bude fungovat jako metoda steepest
  descend (v&nbsp;každém kroku bere nejlepšího souseda lepšího než aktuální stav) a&nbsp;končí v&nbsp;případě, že neexistuje žádné zlepšení.
</p>

<p>
  Pokud implementujeme nový algoritmus, není nutné ho psát úplně od začátku jako implementaci {javadoc "algorithm.Algorithm"}
  rozhraní. V&nbsp;JCOPu existuje abstraktní třída {javadoc "algorithm.BaseAlgorithm"}, která je potomkem všech implementovaných
  algoritmů a&nbsp;my ji můžeme využít, abychom zredukovali množství opakující se práce. Pokud tak učiníme, musíme
  implementovat pouze dvě metody - inicializaci a&nbsp;optimalizační krok:
</p>

<pre class="brush: java;">
package basicusage.algorithm;

import cz.cvut.felk.cig.jcop.algorithm.BaseAlgorithm;
import cz.cvut.felk.cig.jcop.algorithm.CannotContinueException;
import cz.cvut.felk.cig.jcop.algorithm.InvalidProblemException;
import cz.cvut.felk.cig.jcop.problem.ObjectiveProblem;

public class PrimitiveAlgorithm extends BaseAlgorithm {

    public void init(ObjectiveProblem objectiveProblem) throws InvalidProblemException {

    }

    public void optimize() throws CannotContinueException {

    }
}
</pre>

<p>
  Všimněte si, jaké výjimky tyto metody vrací. Výjimka {javadoc "algorithm.InvalidProblemException"} se používá, pokud
  algoritmus dostane problém, který neimplementuje nějaké potřebné rozhraní. V&nbsp;našem příkladu budeme potřebovat, aby
  problém poskytoval počáteční konfiguraci (implementoval rozhraní {javadoc "problem.StartingConfigurationProblem"}).
  Druhá metoda, {javadoc "algorithm.Algorithm#optimize()"}, vyhazuje výjimku {javadoc "algorithm.CannotContinueException"}.
  Pomocí této výjimky říká, že algoritmus již není schopen provádět další optimalizační kroky. V&nbsp;našem případě ji vyhodí,
  pokud nemůže najít konfiguraci s&nbsp;lepší fitness než je naše aktuální. Kdykoli algoritmus vyvolá výjimku
  v&nbsp;{javadoc "algorithm.Algorithm#init(cz.cvut.felk.cig.jcop.problem.ObjectiveProblem)"} nebo {javadoc "algorithm.Algorithm#optimize()"},
  solver by měl okamžitě ukončit svou iteraci (stejně jako kdyby byla splněna jakákoli jiná ukončovací podmínka).
</p>

<p>
  Tím, že používáme {javadoc "algorithm.BaseAlgorithm"} jako základ našeho algoritmu, jsme povinni provést některé kroky
  v {javadoc "algorithm.Algorithm#init(cz.cvut.felk.cig.jcop.problem.ObjectiveProblem)"}. Seznam požadovaných věcí je
  následující:
</p>

<ol>
  <li>Nastavit {javadoc "algorithm.BaseAlgorithm#fitness"} (nejčastěji na {javadoc "problem.Problem#getDefaultFitness()"}</li>
  <li>Nastavit {javadoc "algorithm.BaseAlgorithm#bestConfiguration"} a {javadoc "algorithm.BaseAlgorithm#bestFitness"}
    (pokud jsou k&nbsp;dispozici ještě před prvním optimalizačním krokem)</li>
  <li>Nastavit {javadoc "algorithm.BaseAlgorithm#problem"} na aktuálně řešený problém.</li>
  <li>Nastavit {javadoc "algorithm.BaseAlgorithm#label"} (nepovinné)</li>
</ol>

<p>
  Navíc dávejte pozor na to, že metoda {javadoc "algorithm.Algorithm#init(init(cz.cvut.felk.cig.jcop.problem.ObjectiveProblem))"}
  je volána kdykoli by měl být algoritmus restartován, tudíž se zde musí nastavit všechny interní proměnné, které
  se při restartu mají změnit.
</p>

<p>
  Nyní můžeme začít. Nejprve zkontrolujeme, jestli daný {javadoc "problem.ObjectiveProblem"} obsahuje problém
  požadovaných vlastností:
</p>

<pre class="brush: java;">
public void init(ObjectiveProblem objectiveProblem) throws InvalidProblemException {
    if (!objectiveProblem.hasStartingConfiguration()) throw new InvalidProblemException("Our algorithm requires StartingConfigurationProblem interface");

    this.problem = objectiveProblem;
}
</pre>

<p>
  Jakmile jsme otestovali problém, vezmeme z&nbsp;něj fitness a&nbsp;startovní konfiguraci. Tím, že toto je jediná (a&nbsp;tím pádem nejlepší)
  konfigurace, kterou jsme zatím prošli, uložíme ji do {javadoc "algorithm.BaseAlgorithm#bestConfiguration"}. Dokonce,
  díky chování našeho algoritmu, můžeme používat {javadoc "algorithm.BaseAlgorithm#bestConfiguration"} pořád na ukládání
  aktivní konfigurace. Tento přístup ale není vhodný pro většinu ostatních algoritmů, protože ty často povolují přesun
  do horší konfigurace a&nbsp;proto si ukládají aktivní konfiguraci jiným způsobem.
</p>

<pre class="brush: java;">
public void init(ObjectiveProblem objectiveProblem) throws InvalidProblemException {
    if (!objectiveProblem.hasStartingConfiguration()) throw new InvalidProblemException("Our algorithm requires StartingConfigurationProblem interface");

    this.problem = objectiveProblem;

    this.fitness = objectiveProblem.getDefaultFitness();

    this.bestConfiguration = objectiveProblem.getStartingConfiguration();
    this.bestFitness = this.fitness.getValue(this.bestConfiguration);
}
</pre>

<p>
  Nyní máme náš algoritmus připravený a&nbsp;můžeme implementovat optimalizační krok. V&nbsp;každém volání {javadoc "algorithm.Algorithm#optimize()"}
  expandujeme naši nejlepší konfiguraci pomocí všech operací, které jsou pro ni k&nbsp;dispozici. Pokud najdeme nějaká lepší
  řešení, vezmeme to nejlepší a&nbsp;uložíme si ho {javadoc "algorithm.BaseAlgorithm#bestConfiguration"} (společně s {javadoc "algorithm.BaseAlgorithm#bestFitness"}).
  Pokud žádné není lepší, skončíme výjimkou {javadoc "algorithm.CannotContinueException"}.
</p>

<p>
  V&nbsp;následujícím kódu nejprve vytvoříme <code>nextBestConfiguration</code> a <code>nextBestFitness</code> na ukládání
  kandidátů na nejlepší řešení a {javadoc "problem.OperationIterator"} <code>it</code> na získávání operací. Dalším
  krokem je expandovat pomocí všech operací, což se udělá tak, že expandujeme tak dlouho, dokud iterátor <code>it</code>
  poskytuje další operace ({javadoc "problem.OperationIterator#hasNext()"}). Kdykoli najdeme konfiguraci s&nbsp;lepší fitness,
  uložíme ji. Nakonec, pokud jsme nenašli žádnou lepší, vyvoláme výjimku, jinak uložíme nejlepší nalezenou konfiguraci.
</p>

<pre class="brush: java;">
public void optimize() throws CannotContinueException {
    Configuration nextBestConfiguration = null;
    double nextBestFitness = 0.0;
    OperationIterator it = this.problem.getOperationIterator(this.bestConfiguration);

    // expand with every operation
    while (it.hasNext()) {
        // expand to next state, calculate fitness
        Configuration configuration = it.next().execute(this.bestConfiguration);
        double fitness = this.fitness.getValue(configuration);

        // found better configuration
        if (((nextBestConfiguration == null) &amp;&amp; (fitness > this.bestFitness)) || ((nextBestConfiguration != null) &amp;&amp; (fitness > nextBestFitness))) {
            nextBestConfiguration = configuration;
            nextBestFitness = fitness;
        }
    }

    if (nextBestConfiguration == null) {
        throw new CannotContinueException("Cannot continue, no better configuration");
    }

    this.bestConfiguration = nextBestConfiguration;
    this.bestFitness = nextBestFitness;
}
</pre>

<p>
  Otestujme náš algoritmus, jestli funguje v&nbsp;pořádku. Vše, co potřebujeme, bylo ukázáno v&nbsp;předchozích kapitolách.
  Použijeme problém {javadoc "problem.knapsack.Knapsack"} a&nbsp;solver {javadoc "solver.SimpleSolver"}:
</p>

<pre class="brush: java;">
package basicusage.algorithm;

import cz.cvut.felk.cig.jcop.algorithm.Algorithm;
import cz.cvut.felk.cig.jcop.problem.Problem;
import cz.cvut.felk.cig.jcop.problem.knapsack.Knapsack;
import cz.cvut.felk.cig.jcop.result.render.SimpleRender;
import cz.cvut.felk.cig.jcop.solver.SimpleSolver;
import cz.cvut.felk.cig.jcop.solver.Solver;

public class DemoPrimitiveAlgorithm {
    public static void main(String[] args) {
        // create problem &amp; algorithm
        Problem problem = new Knapsack("9000 4 100 18 114 42 136 88 192 3 223");
        Algorithm algorithm = new PrimitiveAlgorithm();

        // create solver
        Solver solver = new SimpleSolver(algorithm, problem);

        // run!
        solver.run();

        // render results
        solver.render();
    }
}
</pre>

<p>
  Tento kód by vám měl být povědomý, pokud ne, vraťte se ke kapitolám 2.2 až 2.4. Každopádně po spuštění tohoto kusu
  kódu by se mělo v&nbsp;konzoli objevit něco jako kód níže. Pokud ne, nejspíše jste udělali něco jinak než je uvedeno v&nbsp;tomto tutorialu.
</p>

<pre class="brush: plain;">
=== Algorithm PrimitiveAlgorithm [] used on problem Knapsack [line=9000 4 100 18 114 42 136 88 192 3 223] ===
  CPU Time:                       1 [ms]
  System Time:                    1 [ms]
  User Time:                      1 [ms]
  Clock Time:                     1 [ms]
  Optimize counter:               2 [-]
  Optimize/sec (CPU):          2000 [1/s]
  Optimize/sec (Clock):        2000 [1/s]
  Best solution:         Configuration{!="{"}attributes=[0, 0, 1, 1], operationHistory={!="{"}0:Empty knapsack created, 1:AddOperation{!="{"}knapsackItem=KnapsackItem{!="{"}index=3, weight=3, price=223}}, 2:AddOperation{!="{"}knapsackItem=KnapsackItem{!="{"}index=2, weight=88, price=192}}}}
  Depth:                          2 [-]
  Fitness:                    415,0 [-]
  Ended with exception:  cz.cvut.felk.cig.jcop.algorithm.CannotContinueException: Cannot continue, no better configuration
</pre>

<p>
  Algoritmus našel poměrně kvalitní řešení (ne nejlepší, které je [1, 1, 0, 1] s&nbsp;fitness 473,0) a&nbsp;skončil s&nbsp;výjimkou,
  že nemůže dále pokračovat. Oba výsledky jsou podle očekávání. Zdrojové kódy tohoto příkladu jsou ke stažení zde
  (<a href="{$basePath}/media/tutorial/basicusage.algorithm.zip">zip</a>,
  <a href="{$basePath}/media/tutorial/basicusage.algorithm.tgz">tgz</a>, <a href="{$basePath}/media/tutorial/basicusage.algorithm.7z">7z</a>).
</p>

<p>
  Úplný seznam algoritmů implementovaných v&nbsp;JCOPu lze nalézt v <a href="{link Appendix:algorithms}">Příloze B</a>.
</p>