{block #title}Algoritmus{/block}
{block #chapter}2.6{/block}
{block #content}

<p>
  Nyní když víme jak fungují solvery a problémy, nastal čas ukázat jak napsat vlastní algoritmus, který bude tyto problémy
  řešit. Nebudeme zde tvořit velmi efektivní algoritmus, pouze jednoduchou ukázku která bude fungovat jako metoda steepest
  descend (v každém kroku bere nejlepšího souseda lepšího než aktuální stav) a končí v případě, že neexistuje žádné zlepšení.
</p>

<p>
  Pokud implementujeme nový algoritmus, není nutné ho psát úplně od začátku jako implementaci {javadoc "algorithm.Algorithm"}
  rozhraní. V JCOPu existuje abstraktní třída {javadoc "algorithm.BaseAlgorithm"}, která je potomkem všech implementovaných
  algoritmů a my ji můžeme využít, abychom zredukovali množství opakující se práce. Pokud tak učiníme, musíme
  implementovat pouze dvě metody - inicializaci a optimalizační krok:
</p>

<pre class="brush: java;">
package basicusage.algorithm;

import cz.cvut.felk.cig.jcop.algorithm.BaseAlgorithm;
import cz.cvut.felk.cig.jcop.algorithm.CannotContinueException;
import cz.cvut.felk.cig.jcop.algorithm.InvalidProblemException;
import cz.cvut.felk.cig.jcop.problem.ObjectiveProblem;

public class PrimitiveAlgorithm extends BaseAlgorithm {

    public void init(ObjectiveProblem objectiveProblem) throws InvalidProblemException {

    }

    public void optimize() throws CannotContinueException {

    }
}
</pre>

<p>
  Všimněte si, jaké výjimky tyto metody vrací. Výjimka {javadoc "algorithm.InvalidProblemException"} se používá, pokud
  algoritmus dostane problém, který neimplementuje nějaké potřebné rozhraní. V našem příkladu budeme potřebovat, aby
  problém poskytoval počáteční konfiguraci (implementoval rozhraní {javadoc "problem.StartingConfigurationProblem"}).
  Druhá metoda, {javadoc "algorithm.Algorithm#optimize()"}, vyhazuje výjimku {javadoc "algorithm.CannotContinueException"}.
  Pomocí této výjimky říká, že algoritmus již není schopen provádět další optimalizační kroky. V našem případě ji vyhodí,
  pokud nemůže najít konfiguraci s lepší fitness než je naše aktuální. Kdykoli algoritmus vyvolá výjimku
  v&nbsp;{javadoc "algorithm.Algorithm#init(cz.cvut.felk.cig.jcop.problem.ObjectiveProblem)"} nebo {javadoc "algorithm.Algorithm#optimize()"},
  solver by měl okamžitě ukončit svou iteraci (stejně jako kdyby byla splněna jakákoli jiná ukončovací podmínka).
</p>

<p>
  Tím, že používáme {javadoc "algorithm.BaseAlgorithm"} jako základ našeho algoritmu, jsme povinni provést některé kroky
  v {javadoc "algorithm.Algorithm#init(cz.cvut.felk.cig.jcop.problem.ObjectiveProblem)"}. Seznam požadovaných věcí je
  následující:
</p>

<ol>
  <li>Nastavit {javadoc "algorithm.BaseAlgorithm#fitness"} (nejčastěji na {javadoc "problem.Problem#getDefaultFitness()"}</li>
  <li>Nastavit {javadoc "algorithm.BaseAlgorithm#bestConfiguration"} a {javadoc "algorithm.BaseAlgorithm#bestFitness"}
    (pokud jsou k dispozici ještě před prvním optimalizačním krokem)</li>
  <li>Nastavit {javadoc "algorithm.BaseAlgorithm#problem"} na aktuálně řešený problém.</li>
  <li>Nastavit {javadoc "algorithm.BaseAlgorithm#label"} (nepovinné)</li>
</ol>

<p>
  Navíc dávejte pozor na to, že metoda {javadoc "algorithm.Algorithm#init(init(cz.cvut.felk.cig.jcop.problem.ObjectiveProblem))"}
  je volána kdykoli by měl být algoritmus restartován, tudíž se zde musí nastavit všechny interní proměnné, které
  se při restartu mají změnit.
</p>

<p>
  Nyní můžeme začít. Nejprve zkontrolujeme, jestli daný {javadoc "problem.ObjectiveProblem"} obsahuje problém
  požadovaných vlastností:
</p>

<pre class="brush: java;">
public void init(ObjectiveProblem objectiveProblem) throws InvalidProblemException {
    if (!objectiveProblem.hasStartingConfiguration()) throw new InvalidProblemException("Our algorithm requires StartingConfigurationProblem interface");

    this.problem = objectiveProblem;
}
</pre>

<p>
  Jakmile jsme otestovali problém, vezmeme z něj fitness a startovní konfiguraci. Tím, že toto je jediná (a tudíž nejlepší)
  konfigurace, kterou jsme zatím prošli, uložíme ji do {javadoc "algorithm.BaseAlgorithm#bestConfiguration"}. Dokonce,
  díky chování našeho algoritmu, můžeme používat {javadoc "algorithm.BaseAlgorithm#bestConfiguration"} pořád na ukládání
  aktivní konfigurace. Tento přístup ale není vhodný pro většinu ostatních algoritmů, protože ty často povolují přesun
  do horší konfigurace a tudíž si ukládají aktivní konfiguraci jiným způsobem.
</p>

<pre class="brush: java;">
public void init(ObjectiveProblem objectiveProblem) throws InvalidProblemException {
    if (!objectiveProblem.hasStartingConfiguration()) throw new InvalidProblemException("Our algorithm requires StartingConfigurationProblem interface");

    this.problem = objectiveProblem;

    this.fitness = objectiveProblem.getDefaultFitness();

    this.bestConfiguration = objectiveProblem.getStartingConfiguration();
    this.bestFitness = this.fitness.getValue(this.bestConfiguration);
}
</pre>

<p>
  Nyní máme náš algoritmus připravený a můžeme implementovat optimalizační krok. V každém volání {javadoc "algorithm.Algorithm#optimize()"}
  expandujeme naši nejlepší konfiguraci pomocí všech operací, které jsou pro ni k dispozici. Pokud najdeme nějaká lepší
  řešení, vezmeme to nejlepší a uložíme si ho {javadoc "algorithm.BaseAlgorithm#bestConfiguration"} (společně s {javadoc "algorithm.BaseAlgorithm#bestFitness"}).
  Pokud žádné není lepší, skončíme výjimkou {javadoc "algorithm.CannotContinueException"}.
</p>

<p>
  V následujícím kódu nejprve vytvoříme <code>nextBestConfiguration</code> a <code>nextBestFitness</code> na ukládání
  kandidátů na nejlepší řešení a {javadoc "problem.OperationIterator"} <code>it</code> na získávání operací. Dalším
  krokem je expandovat pomocí všech operací, což se udělá tak, že expandujeme tak dlouho, dokud iterátor <code>it</code>
  poskytuje další operace ({javadoc "problem.OperationIterator#hasNext()"}). Kdykoli najdeme konfiguraci s lepší fitness,
  uložíme ji. Nakonec, pokud jsme nenašli žádnou lepší, vyvoláme výjimku, jinak uložíme nejlepší nalezenou konfiguraci.
</p>

<pre class="brush: java;">
public void optimize() throws CannotContinueException {
    Configuration nextBestConfiguration = null;
    double nextBestFitness = 0.0;
    OperationIterator it = this.problem.getOperationIterator(this.bestConfiguration);

    // expand with every operation
    while (it.hasNext()) {
        // expand to next state, calculate fitness
        Configuration configuration = it.next().execute(this.bestConfiguration);
        double fitness = this.fitness.getValue(configuration);

        // found better configuration
        if (((nextBestConfiguration == null) &amp;&amp; (fitness > this.bestFitness)) || ((nextBestConfiguration != null) &amp;&amp; (fitness > nextBestFitness))) {
            nextBestConfiguration = configuration;
            nextBestFitness = fitness;
        }
    }

    if (nextBestConfiguration == null) {
        throw new CannotContinueException("Cannot continue, no better configuration");
    }

    this.bestConfiguration = nextBestConfiguration;
    this.bestFitness = nextBestFitness;
}
</pre>

<p>
  Otestujme náš algoritmus, jestli funguje v pořádku. Vše, co potřebujeme, bylo ukázáno v předchozích kapitolách.
  Použijeme problém {javadoc "problem.knapsack.Knapsack"} a solver {javadoc "solver.SimpleSolver"}:
</p>

<pre class="brush: java;">
package basicusage.algorithm;

import cz.cvut.felk.cig.jcop.algorithm.Algorithm;
import cz.cvut.felk.cig.jcop.problem.Problem;
import cz.cvut.felk.cig.jcop.problem.knapsack.Knapsack;
import cz.cvut.felk.cig.jcop.result.render.SimpleRender;
import cz.cvut.felk.cig.jcop.solver.SimpleSolver;
import cz.cvut.felk.cig.jcop.solver.Solver;

public class DemoPrimitiveAlgorithm {
    public static void main(String[] args) {
        // create problem &amp; algorithm
        Problem problem = new Knapsack("9000 4 100 18 114 42 136 88 192 3 223");
        Algorithm algorithm = new PrimitiveAlgorithm();

        // create solver
        Solver solver = new SimpleSolver(algorithm, problem);

        // run!
        solver.run();

        // render results
        solver.render();
    }
}
</pre>

<p>
  Tento kód by vám měl být povědomý, pokud ne, vraťte se ke kapitolám 2.2 až 2.4. Každopádně po spuštění tohoto kusu
  kódu by se mělo v konzoli objevit něco jako kód níže. Pokud ne, nejspíše jste udělali něco jinak než je uvedeno v
  tomto tutorialu.
</p>

<pre class="brush: plain;">
=== Algorithm PrimitiveAlgorithm [] used on problem Knapsack [line=9000 4 100 18 114 42 136 88 192 3 223] ===
  CPU Time:                       1 [ms]
  System Time:                    1 [ms]
  User Time:                      1 [ms]
  Clock Time:                     1 [ms]
  Optimize counter:               2 [-]
  Optimize/sec (CPU):          2000 [1/s]
  Optimize/sec (Clock):        2000 [1/s]
  Best solution:         Configuration{!="{"}attributes=[0, 0, 1, 1], operationHistory={!="{"}0:Empty knapsack created, 1:AddOperation{!="{"}knapsackItem=KnapsackItem{!="{"}index=3, weight=3, price=223}}, 2:AddOperation{!="{"}knapsackItem=KnapsackItem{!="{"}index=2, weight=88, price=192}}}}
  Depth:                          2 [-]
  Fitness:                    415,0 [-]
  Ended with exception:  cz.cvut.felk.cig.jcop.algorithm.CannotContinueException: Cannot continue, no better configuration
</pre>

<p>
  Algoritmus našel poměrně kvalitní řešení (ne nejlepší, které je [1, 1, 0, 1] s fitness 473,0) a skončil s výjimkou,
  že nemůže dále pokračovat. Oba výsledky jsou podle očekávání. Zdrojové kódy tohoto příkladu jsou ke stažení zde
  (<a href="{$basePath}/media/tutorial/basicusage.algorithm.zip">zip</a>,
  <a href="{$basePath}/media/tutorial/basicusage.algorithm.tgz">tgz</a>, <a href="{$basePath}/media/tutorial/basicusage.algorithm.7z">7z</a>).
</p>

<p>
  Úplný seznam algoritmů implementovaných v JCOPu lze nalézt v <a href="{link Appendix:algorithms}">Příloze B</a>.
</p>