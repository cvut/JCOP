{block #title}Solver{/block}
{block #chapter}2.3{/block}
{block #content}

<p>
  As noted before, solver is kind of a planner. It decides when to use which algorithm, for how long to use it, on which
  problems. Furthermore it collects results and renders then. Solver is defined by {javadoc "solver.Solver"}
  interface. Most methods has default implementations in {javadoc "solver.BaseSolver"} so there
  is actually only one left to implement - {javadoc "solver.Solver#run()"}.
</p>

<p>
  In this method, the solver cycle, algorithm(s) are applied to problem(s). The simplest thing to do is to create
  Solver that takes one algorithm and one problem as arguments:
</p>

<pre class="brush: java;" id="code-primitive-solver-1">
package basicusage.solver;

import cz.cvut.felk.cig.jcop.algorithm.Algorithm;
import cz.cvut.felk.cig.jcop.problem.Problem;
import cz.cvut.felk.cig.jcop.solver.BaseSolver;
import cz.cvut.felk.cig.jcop.solver.Solver;

public class PrimitiveSolver extends BaseSolver implements Solver {
    /**
     * Problem to be solved
     */
    protected Problem problem;
    /**
     * Algorithm to be used
     */
    protected Algorithm algorithm;

    public PrimitiveSolver(Algorithm algorithm, Problem problem) {
        this.algorithm = algorithm;
        this.problem = problem;
    }
}
</pre>

<p>
  Right now we got an error - for not implementing the {javadoc "solver.Solver"} interface. Lets do this.
  First thing we are obliged to do in {javadoc "solver.Solver#run()"} is to call
  {javadoc "algorithm.Algorithm#init(cz.cvut.felk.cig.jcop.problem.ObjectiveProblem)"} to initialize (and restart)
  algorithm on a problem. Don't mind why it takes {javadoc "problem.ObjectiveProblem"} as argument or
  what exactly it does right know, all will be explained later. Just consider algorithm to be prepared. Now we need to
  make the algorithm "work" on a problem. This is called making an optimize step and is invoked by {javadoc "algorithm.Algorithm#optimize()"}
  call. So, let us make solver which will make 10 optimize steps and then ends:
</p>

<pre class="brush: java;" id="code-primitive-solver-2">
package basicusage.solver;

import /** ... */
import cz.cvut.felk.cig.jcop.problem.BaseObjectiveProblem;

public class PrimitiveSolver extends BaseSolver implements Solver {
    /** ... */
    public void run() {
        this.algorithm.init(new BaseObjectiveProblem(this.problem));

        for (int i = 0; i &lt; 10; i++) this.algorithm.optimize();
    }
}
</pre>

<p>
  Well, that's it! If you want to run this solver, just create an instance of it and call its {javadoc "solver.Solver#run()"}
  method. Since we do not know much about algorithms and problems, take the following code and run the main method. You
  will not see any results yet - these will be explained in next chapter. 
</p>

<pre class="brush: java;" id="code-demo-primitive-solver-1">
package basicusage.solver;

import cz.cvut.felk.cig.jcop.algorithm.Algorithm;
import cz.cvut.felk.cig.jcop.algorithm.graphsearch.bfs.BreadthFirstSearch;
import cz.cvut.felk.cig.jcop.problem.Problem;
import cz.cvut.felk.cig.jcop.problem.knapsack.Knapsack;
import cz.cvut.felk.cig.jcop.solver.Solver;

public class DemoPrimitiveSolver {
    public static void main(String[] args) {
        // create problem &amp; algorithm
        Problem problem = new Knapsack("9000 4 100 18 114 42 136 88 192 3 223");
        Algorithm algorithm = new BreadthFirstSearch();

        // create solver
        Solver solver = new PrimitiveSolver(algorithm, problem);

        // run!
        solver.run();
    }
}

</pre>

<p>
  If it finishes without exception, you've made your first own solver! If there is an error, take a look back through
  this tutorial and try to find our what you have done differently. Both classes could be downloaded here 
  (<a href="{$basePath}/media/tutorial/basicusage.solver.zip">zip</a>, <a href="{$basePath}/media/tutorial/basicusage.solver.tgz">tgz</a>, 
  <a href="{$basePath}/media/tutorial/basicusage.solver.7z">7z</a>).
</p>

<h3>Bundled Solvers</h3>

<p>
  There are several Solvers bundled with JCOP and they are preferred to use instead of creating your own. {javadoc
  "solver.SimpleSolver"} is used if you want to run a single algorithm on a single problem, usually in development
  stage. {javadoc "solver.AlgorithmCompareSolver"} is used to benchmark several algorithms against one problem. For a
  full list see <a href="{link Appendix:solvers}">Appendix A</a>.
</p>

<h3>StopConditions</h3>

<p>
  An important part of Solver are {javadoc "solver.condition.StopCondition", "StopConditions"}. We have not covered them
  in our solver to make things easy to understand. In real use however, we need to control when should solver iterations
  stop. To accomplish this, JCOP provides you with StopCondition concept.
</p>

<p>
  A solver can have several stop conditions registered to it and whenever at least one is met, it ends (only current
  solver iteration). Stop conditions are added to solver by {javadoc "solver.Solver#addStopCondition(cz.cvut.felk.cig.jcop.solver.condition.StopCondition)"}.
  Conditions works as listeners (and are automatically registered as such) for solver which then sends them messages
  about its progress. After every optimization step it evaluates if any condition was met and possibly ends.
</p>

<p>
  There are several stop conditions bundled with JCOP. For the full list and description, see <a href="{link Appendix:stopConditions}">Appendix D</a>.
  The usage is quite simple:
</p>

<pre class="brush: java;">
package basicusage.solver;

import cz.cvut.felk.cig.jcop.algorithm.Algorithm;
import cz.cvut.felk.cig.jcop.algorithm.graphsearch.bfs.BreadthFirstSearch;
import cz.cvut.felk.cig.jcop.problem.Problem;
import cz.cvut.felk.cig.jcop.problem.knapsack.Knapsack;
import cz.cvut.felk.cig.jcop.solver.SimpleSolver;
import cz.cvut.felk.cig.jcop.solver.Solver;
import cz.cvut.felk.cig.jcop.solver.condition.IterationCondition;
import cz.cvut.felk.cig.jcop.solver.condition.TimeoutCondition;

public class DemoCondition {
    public static void main(String[] args) {
        // create problem &amp; algorithm
        Problem problem = new Knapsack("9000 4 100 18 114 42 136 88 192 3 223");
        Algorithm algorithm = new BreadthFirstSearch();

        // create solver
        Solver solver = new SimpleSolver(algorithm, problem);

        // max 10 optimizations
        solver.addStopCondition(new IterationCondition(10));
        // and max 10ms of solver iteration run
        solver.addStopCondition(new TimeoutCondition(10));

        // run!
        solver.run();
    }
}
</pre>

<p>
  Now the solver (note that we use {javadoc "solver.SimpleSolver"} now) will attempt maximum of 10 optimization and will
  run no more than 10ms (of CPU time, see <a href="{link util}">util</a> for details).
</p>