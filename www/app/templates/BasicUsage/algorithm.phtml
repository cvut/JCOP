{block #title}Algorithm{/block}
{block #chapter}2.6{/block}
{block #content}

<p>
  Now that we know how solvers and algorithms work, we will take a look on how to write an algorithm which will be able
  to solve these problems. We will not create a very effective algorithm here, just a simple one which works like steepest
  descend (takes the best improvement) and if there are no more improving steps it ends. 
</p>

<p>
  First thing to know is that we need not implement {javadoc "algorithm.Algorithm"} from scratch. There is abstract
  class {javadoc "algorithm.BaseAlgorithm"} which we could use to reduce the amount of repetitive work. If we do so, we
  need to implement only two methods, initialization and optimization step:
</p>

<pre class="brush: java;">
package basicusage.algorithm;

import cz.cvut.felk.cig.jcop.algorithm.BaseAlgorithm;
import cz.cvut.felk.cig.jcop.algorithm.CannotContinueException;
import cz.cvut.felk.cig.jcop.algorithm.InvalidProblemException;
import cz.cvut.felk.cig.jcop.problem.ObjectiveProblem;

public class PrimitiveAlgorithm extends BaseAlgorithm {

    public void init(ObjectiveProblem objectiveProblem) throws InvalidProblemException {

    }

    public void optimize() throws CannotContinueException {

    }
}
</pre>

<p>
  Note the exceptions those methods raises. {javadoc "algorithm.InvalidProblemException"} is used to denote that
  algorithm required some interface which supplied problem (wrapped in {javadoc "problem.ObjectiveProblem"} as shown in
  previous chapter) does not implement. In our example, we will require the problem to supply starting configuration by
  implementing {javadoc "problem.StartingConfigurationProblem"}. Second method, {javadoc "algorithm.Algorithm#optimize()"}
  throws a {javadoc "algorithm.CannotContinueException"}. This exception is raised when algorithm has nothing more to
  do. In our example we will throw it when we cannot find a configuration with better fitness than current one. Whenever
  any exception is raised in {javadoc "algorithm.Algorithm#optimize()"}, solver should immediately stop current solver
  iteration as if any other condition was met.
</p>

<p>
  Also, since we use {javadoc "algorithm.BaseAlgorithm"} we are obliged to do certain steps in {javadoc "algorithm.Algorithm#init(cz.cvut.felk.cig.jcop.problem.ObjectiveProblem)"}.
  List of things required to do is as follows:
</p>

<ol>
  <li>Set {javadoc "algorithm.BaseAlgorithm#fitness"} (usually to {javadoc "problem.Problem#getDefaultFitness()"}</li>
  <li>Set {javadoc "algorithm.BaseAlgorithm#bestConfiguration"} and {javadoc "algorithm.BaseAlgorithm#bestFitness"}
    (if they are available before first optimize step)</li>
  <li>Set {javadoc "algorithm.BaseAlgorithm#problem"} to problem being currently solved.</li>
  <li>Set {javadoc "algorithm.BaseAlgorithm#label"} (optional)</li>
</ol>

<p>
  Also keep in mind that {javadoc "algorithm.Algorithm#init(init(cz.cvut.felk.cig.jcop.problem.ObjectiveProblem))"} is
  called whenever there is need to restart the algorithm, so it should reset all internal variables.
</p>

<p>
  Now we can start. First we check if given ObjectiveProblem holds valid problem:
</p>

<pre class="brush: java;">
public void init(ObjectiveProblem objectiveProblem) throws InvalidProblemException {
    if (!objectiveProblem.hasStartingConfiguration()) throw new InvalidProblemException("Our algorithm requires StartingConfigurationProblem interface");
    
    this.problem = objectiveProblem;
}
</pre>

<p>
  Once we have our problem checked for type, we will take the fitness and starting configuration. Since it is only
  configuration we have visited, we will store it to {javadoc "algorithm.BaseAlgorithm#bestConfiguration"}. In fact
  because of nature of our algorithm, we will use {javadoc "algorithm.BaseAlgorithm#bestConfiguration"} to store our
  active configuration all the time. Note that most other algorithms would not take this approach since they usually
  allows expanding to worse configuration so they have to store active configuration in some other way.
</p>

<pre class="brush: java;">
public void init(ObjectiveProblem objectiveProblem) throws InvalidProblemException {
    if (!objectiveProblem.hasStartingConfiguration()) throw new InvalidProblemException("Our algorithm requires StartingConfigurationProblem interface");

    this.problem = objectiveProblem;

    this.fitness = objectiveProblem.getDefaultFitness();

    this.bestConfiguration = objectiveProblem.getStartingConfiguration();
    this.bestFitness = this.fitness.getValue(this.bestConfiguration);
}
</pre>

<p>
  Now we have our algorithm prepared, we will implement one optimization step. In each {javadoc "algorithm.Algorithm#optimize()"}
  we expand current best configuration with all operations available for it. If any one is better, take the best one and
  assign it to {javadoc "algorithm.BaseAlgorithm#bestConfiguration"} (along with {javadoc "algorithm.BaseAlgorithm#bestFitness"}).
  If none is better than current best solution, end with {javadoc "algorithm.CannotContinueException"}. 
</p>

<p>
  In code below, first we create <code>nextBestConfiguration</code> and <code>nextBestFitness</code> to store candidates
  for next best solution and an operation iterator <code>it</code> to get operations. Next step is to expand with all
  operations we got, which is done by expanding as long as iterator provides operations
  ({javadoc "problem.OperationIterator#hasNext()"}). Whenever we found a configuration with better fitness, we store it.
  At least if we did not find any one better, end raising an exception. Otherwise store best found configuration.
</p>

<pre class="brush: java;">
public void optimize() throws CannotContinueException {
    Configuration nextBestConfiguration = null;
    double nextBestFitness = 0.0;
    OperationIterator it = this.problem.getOperationIterator(this.bestConfiguration);

    // expand with every operation
    while (it.hasNext()) {
        // expand to next state, calculate fitness
        Configuration configuration = it.next().execute(this.bestConfiguration);
        double fitness = this.fitness.getValue(configuration);

        // found better configuration
        if (((nextBestConfiguration == null) &amp;&amp; (fitness > this.bestFitness)) || ((nextBestConfiguration != null) &amp;&amp; (fitness > nextBestFitness))) {
            nextBestConfiguration = configuration;
            nextBestFitness = fitness;
        }
    }

    if (nextBestConfiguration == null) {
        throw new CannotContinueException("Cannot continue, no better configuration");
    }

    this.bestConfiguration = nextBestConfiguration;
    this.bestFitness = nextBestFitness;
}
</pre>

<p>
  Now we have our algorithm, lets test it how it works! All we require has been shown in previous chapters. We will use
  {javadoc "problem.knapsack.Knapsack"} problem and {javadoc "solver.SimpleSolver"} solver:
</p>

<pre class="brush: java;">
package basicusage.algorithm;

import cz.cvut.felk.cig.jcop.algorithm.Algorithm;
import cz.cvut.felk.cig.jcop.problem.Problem;
import cz.cvut.felk.cig.jcop.problem.knapsack.Knapsack;
import cz.cvut.felk.cig.jcop.result.render.SimpleRender;
import cz.cvut.felk.cig.jcop.solver.SimpleSolver;
import cz.cvut.felk.cig.jcop.solver.Solver;

public class DemoPrimitiveAlgorithm {
    public static void main(String[] args) {
        // create problem &amp; algorithm
        Problem problem = new Knapsack("9000 4 100 18 114 42 136 88 192 3 223");
        Algorithm algorithm = new PrimitiveAlgorithm();

        // create solver
        Solver solver = new SimpleSolver(algorithm, problem);

        // run!
        solver.run();

        // render results
        solver.render();
    }
}
</pre>

<p>
  You should be familiar with above, if not, revert to chapters 2.2-2.4. Either way, after you run this piece of code,
  you should see this in console. If not, you have probably done something wrong in this tutorial.
</p>

<pre class="brush: plain;">
=== Algorithm PrimitiveAlgorithm [] used on problem Knapsack [line=9000 4 100 18 114 42 136 88 192 3 223] ===
  CPU Time:                       1 [ms]
  System Time:                    1 [ms]
  User Time:                      1 [ms]
  Clock Time:                     1 [ms]
  Optimize counter:               2 [-]
  Optimize/sec (CPU):          2000 [1/s]
  Optimize/sec (Clock):        2000 [1/s]
  Best solution:         Configuration{!="{"}attributes=[0, 0, 1, 1], operationHistory={!="{"}0:Empty knapsack created, 1:AddOperation{!="{"}knapsackItem=KnapsackItem{!="{"}index=3, weight=3, price=223}}, 2:AddOperation{!="{"}knapsackItem=KnapsackItem{!="{"}index=2, weight=88, price=192}}}}
  Depth:                          2 [-]
  Fitness:                    415,0 [-]
  Ended with exception:  cz.cvut.felk.cig.jcop.algorithm.CannotContinueException: Cannot continue, no better configuration
</pre>

<p>
  We have found reasonably good solution (not the best one, which is [1, 1, 0, 1] with fitness 473,0) and algorithm
  ended with an exception that it cannot continue. Both results are as we expected. Source codes of this example could
  be downloaded here  (<a href="{$basePath}/media/tutorial/basicusage.algorithm.zip">zip</a>,
  <a href="{$basePath}/media/tutorial/basicusage.algorithm.tgz">tgz</a>, <a href="{$basePath}/media/tutorial/basicusage.algorithm.7z">7z</a>).
</p>

<p>
  Full list of bundled algorithms can be found in <a href="{link Appendix:algorithms}">Appendix B</a>.
</p>